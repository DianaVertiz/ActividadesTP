.TH "ccan_18xx_43xx.h" 3 "Viernes, 14 de Septiembre de 2018" "Ejercicio 1 - TP 5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ccan_18xx_43xx.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Estructuras de datos"

.in +1c
.ti -1c
.RI "struct \fBCCAN_IF_T\fP"
.br
.RI "\fICCAN message interface register block structure\&. \fP"
.ti -1c
.RI "struct \fBLPC_CCAN_T\fP"
.br
.RI "\fICCAN Controller Area Network register block structure\&. \fP"
.ti -1c
.RI "struct \fBCCAN_MSG_OBJ_T\fP"
.br
.RI "\fICAN message object structure\&. \fP"
.in -1c
.SS "'defines'"

.in +1c
.ti -1c
.RI "#define \fBCCAN_CTRL_INIT\fP   (1 << 0)"
.br
.ti -1c
.RI "#define \fBCCAN_CTRL_IE\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBCCAN_CTRL_SIE\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBCCAN_CTRL_EIE\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBCCAN_CTRL_DAR\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBCCAN_CTRL_CCE\fP   (1 << 6)"
.br
.ti -1c
.RI "#define \fBCCAN_CTRL_TEST\fP   (1 << 7)"
.br
.ti -1c
.RI "#define \fBCCAN_STAT_LEC_MASK\fP   (0x07)		/* Mask for Last Error Code */"
.br
.ti -1c
.RI "#define \fBCCAN_STAT_TXOK\fP   (1 << 3)	/* Transmitted a message successfully */"
.br
.ti -1c
.RI "#define \fBCCAN_STAT_RXOK\fP   (1 << 4)	/* Received a message successfully */"
.br
.ti -1c
.RI "#define \fBCCAN_STAT_EPASS\fP   (1 << 5)	/* The CAN controller is in the \fBerror\fP passive state*/"
.br
.ti -1c
.RI "#define \fBCCAN_STAT_EWARN\fP   (1 << 6)	/*At least one of the \fBerror\fP counters in the EC has reached the \fBerror\fP warning limit of 96\&.*/"
.br
.ti -1c
.RI "#define \fBCCAN_STAT_BOFF\fP   (1 << 7)	/*The CAN controller is in busoff state\&.*/"
.br
.ti -1c
.RI "#define \fBCCAN_INT_NO_PENDING\fP   0"
.br
.ti -1c
.RI "#define \fBCCAN_INT_STATUS\fP   0x8000"
.br
.ti -1c
.RI "#define \fBCCAN_INT_MSG_NUM\fP(n)   (n)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_BASIC_MODE\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_SILENT_MODE\fP   (1 << 3)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_LOOPBACK_MODE\fP   (1 << 4)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_TD_CONTROLLED\fP   (0)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_TD_MONITORED\fP   (1 << 5)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_TD_DOMINANT\fP   (2 << 5)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_TD_RECESSIVE\fP   (3 << 5)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_RD_DOMINANT\fP   (0)"
.br
.ti -1c
.RI "#define \fBCCAN_TEST_RD_RECESSIVE\fP   (1 << 7)"
.br
.ti -1c
.RI "#define \fBCCAN_SEG1_DEFAULT_VAL\fP   5"
.br
.ti -1c
.RI "#define \fBCCAN_SEG2_DEFAULT_VAL\fP   4"
.br
.ti -1c
.RI "#define \fBCCAN_SJW_DEFAULT_VAL\fP   0"
.br
.ti -1c
.RI "#define \fBCCAN_MSG_MAX_NUM\fP   32"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDREQ_MSG_NUM\fP(n)   (n)			/* Message number (1\->20) */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDREQ_BUSY\fP   0x8000			/* 1 is writing is progress, cleared when RD/WR done */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_DATAB\fP   (1 << 0)		/** 1 is transfer data byte 4\-7 to message object, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_DATAA\fP   (1 << 1)		/** 1 is transfer data byte 0\-3 to message object, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_W_TXRQST\fP   (1 << 2)		/** Request a transmission\&. Set the TXRQST bit IF1/2_MCTRL\&. */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_R_NEWDAT\fP   (1 << 2)		/** Clear NEWDAT bit in the message object */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_R_CLRINTPND\fP   (1 << 3)		/** Clear INTPND bit in the message object\&. */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_CTRL\fP   (1 << 4)		/** 1 is transfer the CTRL bit to the message object, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_ARB\fP   (1 << 5)		/** 1 is transfer the ARB bits to the message object, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_MASK\fP   (1 << 6)		/** 1 is transfer the MASK bit to the message object, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_WR\fP   (1 << 7)		/*  Tranfer direction: Write */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_RD\fP   (0)				/*  Tranfer direction: Read */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_CMDMSK_TRANSFER_ALL\fP"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MASK2_MXTD\fP   (1 << 15)				/* 1 is extended identifier bit is used in the RX filter unit, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MASK2_MDIR\fP(n)   (((n) & 0x01) <<  14)	/* 1 is direction bit is used in the RX filter unit, 0 is not */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_ARB2_DIR\fP(n)   (((n) & 0x01) << 13)	/* 1: Dir = transmit, 0: Dir = receive */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_ARB2_XTD\fP   (1 << 14)		/* Extended identifier bit is used*/"
.br
.ti -1c
.RI "#define \fBCCAN_IF_ARB2_MSGVAL\fP   (1 << 15)		/* Message valid bit, 1 is valid in the MO handler, 0 is ignored */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_DLC_MSK\fP   0x000F			/* bit mask for DLC */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_EOB\fP   (1 << 7)		/* End of buffer, always write to 1 */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_TXRQ\fP   (1 << 8)		/* 1 is TxRqst enabled */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_RMTEN\fP(n)   (((n) & 1UL) << 9)	/* 1 is remote frame enabled */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_RXIE\fP   (1 << 10)		/* 1 is RX interrupt enabled */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_TXIE\fP   (1 << 11)		/* 1 is TX interrupt enabled */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_UMSK\fP   (1 << 12)		/* 1 is to use the mask for the receive filter mask\&. */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_INTP\fP   (1 << 13)		/* 1 indicates message object is an interrupt source */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_MLST\fP   (1 << 14)		/* 1 indicates a message loss\&. */"
.br
.ti -1c
.RI "#define \fBCCAN_IF_MCTRL_NEWD\fP   (1 << 15)		/* 1 indicates new data is in the message buffer\&.  */"
.br
.ti -1c
.RI "#define \fBCCAN_MSG_ID_STD_MASK\fP   0x07FF"
.br
.ti -1c
.RI "#define \fBCCAN_MSG_ID_EXT_MASK\fP   0x1FFFFFFF"
.br
.in -1c
.SS "Enumeraciones"

.in +1c
.ti -1c
.RI "enum \fBCCAN_LEC_T\fP { \fBCCAN_LEC_NO_ERROR\fP, \fBCCAN_LEC_STUFF_ERROR\fP, \fBCCAN_LEC_FORM_ERROR\fP, \fBCCAN_LEC_ACK_ERROR\fP, \fBCCAN_LEC_BIT1_ERROR\fP, \fBCCAN_LEC_BIT0_ERROR\fP, \fBCCAN_LEC_CRC_ERROR\fP }
.RI "\fILast Error Code definition\&. \fP""
.br
.ti -1c
.RI "enum \fBCCAN_TRANSFER_DIR_T\fP { \fBCCAN_RX_DIR\fP, \fBCCAN_TX_DIR\fP }
.RI "\fICCAN Transfer direction definition\&. \fP""
.br
.ti -1c
.RI "enum \fBCCAN_MSG_IF_T\fP { \fBCCAN_MSG_IF1\fP = 0, \fBCCAN_MSG_IF2\fP = 1 }"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_EnableInt\fP (\fBLPC_CCAN_T\fP *pCCAN, uint32_t mask)"
.br
.RI "\fIEnable CCAN Interrupts\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_DisableInt\fP (\fBLPC_CCAN_T\fP *pCCAN, uint32_t mask)"
.br
.RI "\fIDisable CCAN Interrupts\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_CCAN_GetIntID\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIGet the source ID of an interrupt\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_CCAN_GetStatus\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIGet the CCAN status register\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_SetStatus\fP (\fBLPC_CCAN_T\fP *pCCAN, uint32_t val)"
.br
.RI "\fISet the CCAN status\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_ClearStatus\fP (\fBLPC_CCAN_T\fP *pCCAN, uint32_t val)"
.br
.RI "\fIClear the status of CCAN bus\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint8_t \fBChip_CCAN_GetErrCounter\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_TRANSFER_DIR_T\fP dir)"
.br
.RI "\fIGet the current value of the transmit/receive error counter\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_EnableTestMode\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIEnable test mode in CCAN\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_DisableTestMode\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIEnable test mode in CCAN\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_ConfigTestMode\fP (\fBLPC_CCAN_T\fP *pCCAN, uint32_t cfg)"
.br
.RI "\fIEnable/Disable test mode in CCAN\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_EnableAutoRetransmit\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIEnable automatic retransmission\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_DisableAutoRetransmit\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIDisable automatic retransmission\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_CCAN_GetTxRQST\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIGet the transmit repuest bit in all message objects\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_Init\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIInitialize the CCAN peripheral, free all message object in RAM\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_DeInit\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fIDe-initialize the CCAN peripheral\&. \fP"
.ti -1c
.RI "\fBStatus\fP \fBChip_CCAN_SetBitRate\fP (\fBLPC_CCAN_T\fP *pCCAN, uint32_t bitRate)"
.br
.RI "\fISelect bit rate for CCAN bus\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_TransferMsgObject\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint32_t mask, uint32_t msgNum)"
.br
.RI "\fITranfer message object between IF registers and Message RAM\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_SetMsgObject\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, \fBCCAN_TRANSFER_DIR_T\fP dir, bool remoteFrame, uint8_t msgNum, const \fBCCAN_MSG_OBJ_T\fP *pMsgObj)"
.br
.RI "\fISet a message into the message object in message RAM\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_GetMsgObject\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint8_t msgNum, \fBCCAN_MSG_OBJ_T\fP *pMsgObj)"
.br
.RI "\fIGet a message object in message RAM into the message buffer\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_SetValidMsg\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint8_t msgNum, bool valid)"
.br
.RI "\fIEnable/Disable the message object to valid\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_CCAN_GetValidMsg\fP (\fBLPC_CCAN_T\fP *pCCAN)"
.br
.RI "\fICheck the message objects is valid or not\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_ClearMsgIntPend\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint8_t msgNum, \fBCCAN_TRANSFER_DIR_T\fP dir)"
.br
.RI "\fIClear the pending message interrupt\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_CCAN_ClearNewDataFlag\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint8_t msgNum)"
.br
.RI "\fIClear new data flag bit in the message object\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_Send\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, bool remoteFrame, \fBCCAN_MSG_OBJ_T\fP *pMsgObj)"
.br
.RI "\fISend a message\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_AddReceiveID\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint32_t id)"
.br
.RI "\fIRegister a message ID for receiving\&. \fP"
.ti -1c
.RI "void \fBChip_CCAN_DeleteReceiveID\fP (\fBLPC_CCAN_T\fP *pCCAN, \fBCCAN_MSG_IF_T\fP IFSel, uint32_t id)"
.br
.RI "\fIRemove a registered message ID from receiving\&. \fP"
.in -1c
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para Ejercicio 1 - TP 5 del código fuente\&.
