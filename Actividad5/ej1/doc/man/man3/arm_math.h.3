.TH "arm_math.h" 3 "Viernes, 14 de Septiembre de 2018" "Ejercicio 1 - TP 5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
arm_math.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'ARMCM4\&.h'\fP
.br
\fC#include 'string\&.h'\fP
.br
\fC#include 'math\&.h'\fP
.br

.SS "Estructuras de datos"

.in +1c
.ti -1c
.RI "struct \fBarm_fir_instance_q7\fP"
.br
.RI "\fIInstance structure for the Q7 FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_biquad_casd_df1_inst_q15\fP"
.br
.RI "\fIInstance structure for the Q15 Biquad cascade filter\&. \fP"
.ti -1c
.RI "struct \fBarm_biquad_casd_df1_inst_q31\fP"
.br
.RI "\fIInstance structure for the Q31 Biquad cascade filter\&. \fP"
.ti -1c
.RI "struct \fBarm_biquad_casd_df1_inst_f32\fP"
.br
.RI "\fIInstance structure for the floating-point Biquad cascade filter\&. \fP"
.ti -1c
.RI "struct \fBarm_matrix_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point matrix structure\&. \fP"
.ti -1c
.RI "struct \fBarm_matrix_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 matrix structure\&. \fP"
.ti -1c
.RI "struct \fBarm_matrix_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 matrix structure\&. \fP"
.ti -1c
.RI "struct \fBarm_pid_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 PID Control\&. \fP"
.ti -1c
.RI "struct \fBarm_pid_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 PID Control\&. \fP"
.ti -1c
.RI "struct \fBarm_pid_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point PID Control\&. \fP"
.ti -1c
.RI "struct \fBarm_linear_interp_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point Linear Interpolate function\&. \fP"
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point bilinear interpolation function\&. \fP"
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 bilinear interpolation function\&. \fP"
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 bilinear interpolation function\&. \fP"
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_q7\fP"
.br
.RI "\fIInstance structure for the Q15 bilinear interpolation function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_radix2_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_radix4_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_radix2_instance_q31\fP"
.br
.RI "\fIInstance structure for the Radix-2 Q31 CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_radix4_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_radix2_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_radix4_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_cfft_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point CFFT/CIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_rfft_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 RFFT/RIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_rfft_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 RFFT/RIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_rfft_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point RFFT/RIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_rfft_fast_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point RFFT/RIFFT function\&. \fP"
.ti -1c
.RI "struct \fBarm_dct4_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point DCT4/IDCT4 function\&. \fP"
.ti -1c
.RI "struct \fBarm_dct4_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 DCT4/IDCT4 function\&. \fP"
.ti -1c
.RI "struct \fBarm_dct4_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 DCT4/IDCT4 function\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_decimate_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 FIR decimator\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_decimate_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 FIR decimator\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_decimate_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point FIR decimator\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_interpolate_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 FIR interpolator\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_interpolate_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 FIR interpolator\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_interpolate_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point FIR interpolator\&. \fP"
.ti -1c
.RI "struct \fBarm_biquad_cas_df1_32x64_ins_q31\fP"
.br
.RI "\fIInstance structure for the high precision Q31 Biquad cascade filter\&. \fP"
.ti -1c
.RI "struct \fBarm_biquad_cascade_df2T_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point transposed direct form II Biquad cascade filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_lattice_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 FIR lattice filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_lattice_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 FIR lattice filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_lattice_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point FIR lattice filter\&. \fP"
.ti -1c
.RI "struct \fBarm_iir_lattice_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 IIR lattice filter\&. \fP"
.ti -1c
.RI "struct \fBarm_iir_lattice_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 IIR lattice filter\&. \fP"
.ti -1c
.RI "struct \fBarm_iir_lattice_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point IIR lattice filter\&. \fP"
.ti -1c
.RI "struct \fBarm_lms_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point LMS filter\&. \fP"
.ti -1c
.RI "struct \fBarm_lms_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 LMS filter\&. \fP"
.ti -1c
.RI "struct \fBarm_lms_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 LMS filter\&. \fP"
.ti -1c
.RI "struct \fBarm_lms_norm_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point normalized LMS filter\&. \fP"
.ti -1c
.RI "struct \fBarm_lms_norm_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 normalized LMS filter\&. \fP"
.ti -1c
.RI "struct \fBarm_lms_norm_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 normalized LMS filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_f32\fP"
.br
.RI "\fIInstance structure for the floating-point sparse FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_q31\fP"
.br
.RI "\fIInstance structure for the Q31 sparse FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_q15\fP"
.br
.RI "\fIInstance structure for the Q15 sparse FIR filter\&. \fP"
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_q7\fP"
.br
.RI "\fIInstance structure for the Q7 sparse FIR filter\&. \fP"
.in -1c
.SS "'defines'"

.in +1c
.ti -1c
.RI "#define \fB__CMSIS_GENERIC\fP   /* disable \fBNVIC\fP and Systick functions */"
.br
.ti -1c
.RI "#define \fBDELTA_Q31\fP   (0x100)"
.br
.RI "\fIMacros required for reciprocal calculation in Normalized LMS\&. \fP"
.ti -1c
.RI "#define \fBDELTA_Q15\fP   0x5"
.br
.ti -1c
.RI "#define \fBINDEX_MASK\fP   0x0000003F"
.br
.ti -1c
.RI "#define \fBPI\fP   3\&.14159265358979f"
.br
.ti -1c
.RI "#define \fBTABLE_SIZE\fP   256"
.br
.RI "\fIMacros required for SINE and COSINE Fast math approximations\&. \fP"
.ti -1c
.RI "#define \fBTABLE_SPACING_Q31\fP   0x800000"
.br
.ti -1c
.RI "#define \fBTABLE_SPACING_Q15\fP   0x80"
.br
.ti -1c
.RI "#define \fBINPUT_SPACING\fP   0xB60B61"
.br
.RI "\fIMacros required for SINE and COSINE Controller functions\&. \fP"
.ti -1c
.RI "#define \fBALIGN4\fP"
.br
.RI "\fIMacro for Unaligned Support\&. \fP"
.ti -1c
.RI "#define \fB__SIMD32\fP(addr)   (*(__SIMD32_TYPE **) & (addr))"
.br
.RI "\fIdefinition to read/write two 16 bit values\&. \fP"
.ti -1c
.RI "#define \fB__SIMD32_CONST\fP(addr)   ((__SIMD32_TYPE *)(addr))"
.br
.ti -1c
.RI "#define \fB_SIMD32_OFFSET\fP(addr)   (*(__SIMD32_TYPE *)  (addr))"
.br
.ti -1c
.RI "#define \fB__SIMD64\fP(addr)   (*(int64_t **) & (addr))"
.br
.ti -1c
.RI "#define \fB__PACKq7\fP(v0,  v1,  v2,  v3)"
.br
.RI "\fIdefinition to pack four 8 bit values\&. \fP"
.in -1c
.SS "'typedefs'"

.in +1c
.ti -1c
.RI "typedef int8_t \fBq7_t\fP"
.br
.RI "\fI8-bit fractional data type in 1\&.7 format\&. \fP"
.ti -1c
.RI "typedef int16_t \fBq15_t\fP"
.br
.RI "\fI16-bit fractional data type in 1\&.15 format\&. \fP"
.ti -1c
.RI "typedef int32_t \fBq31_t\fP"
.br
.RI "\fI32-bit fractional data type in 1\&.31 format\&. \fP"
.ti -1c
.RI "typedef int64_t \fBq63_t\fP"
.br
.RI "\fI64-bit fractional data type in 1\&.63 format\&. \fP"
.ti -1c
.RI "typedef float \fBfloat32_t\fP"
.br
.RI "\fI32-bit floating-point type definition\&. \fP"
.ti -1c
.RI "typedef double \fBfloat64_t\fP"
.br
.RI "\fI64-bit floating-point type definition\&. \fP"
.in -1c
.SS "Enumeraciones"

.in +1c
.ti -1c
.RI "enum \fBarm_status\fP { \fBARM_MATH_SUCCESS\fP = 0, \fBARM_MATH_ARGUMENT_ERROR\fP = -1, \fBARM_MATH_LENGTH_ERROR\fP = -2, \fBARM_MATH_SIZE_MISMATCH\fP = -3, \fBARM_MATH_NANINF\fP = -4, \fBARM_MATH_SINGULAR\fP = -5, \fBARM_MATH_TEST_FAILURE\fP = -6 }
.RI "\fIError status returned by some functions in the library\&. \fP""
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "void \fBarm_fir_q7\fP (const \fBarm_fir_instance_q7\fP *S, \fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q7 FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_init_q7\fP (\fBarm_fir_instance_q7\fP *S, uint16_t numTaps, \fBq7_t\fP *pCoeffs, \fBq7_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q7 FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_q15\fP (const \fBarm_fir_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_fast_q15\fP (const \fBarm_fir_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_init_q15\fP (\fBarm_fir_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q15 FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_q31\fP (const \fBarm_fir_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_fast_q31\fP (const \fBarm_fir_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_fir_init_q31\fP (\fBarm_fir_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q31 FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_f32\fP (const \fBarm_fir_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_init_f32\fP (\fBarm_fir_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the floating-point FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_q15\fP (const \fBarm_biquad_casd_df1_inst_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_init_q15\fP (\fBarm_biquad_casd_df1_inst_q15\fP *S, uint8_t numStages, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, int8_t postShift)"
.br
.RI "\fIInitialization function for the Q15 Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_fast_q15\fP (const \fBarm_biquad_casd_df1_inst_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_q31\fP (const \fBarm_biquad_casd_df1_inst_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_fast_q31\fP (const \fBarm_biquad_casd_df1_inst_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_init_q31\fP (\fBarm_biquad_casd_df1_inst_q31\fP *S, uint8_t numStages, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, int8_t postShift)"
.br
.RI "\fIInitialization function for the Q31 Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_f32\fP (const \fBarm_biquad_casd_df1_inst_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_init_f32\fP (\fBarm_biquad_casd_df1_inst_f32\fP *S, uint8_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "\fIInitialization function for the floating-point Biquad cascade filter\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_add_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "\fIFloating-point matrix addition\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_add_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "\fIQ15 matrix addition\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_add_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "\fIQ31 matrix addition\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_trans_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrc, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "\fIFloating-point matrix transpose\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_trans_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrc, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "\fIQ15 matrix transpose\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_trans_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrc, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "\fIQ31 matrix transpose\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "\fIFloating-point matrix multiplication\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst, \fBq15_t\fP *pState)"
.br
.RI "\fIQ15 matrix multiplication\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_fast_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst, \fBq15_t\fP *pState)"
.br
.RI "\fIQ15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "\fIQ31 matrix multiplication\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_fast_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "\fIQ31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_sub_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "\fIFloating-point matrix subtraction\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_sub_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "\fIQ15 matrix subtraction\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_sub_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "\fIQ31 matrix subtraction\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_scale_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrc, \fBfloat32_t\fP scale, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "\fIFloating-point matrix scaling\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_scale_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrc, \fBq15_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "\fIQ15 matrix scaling\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_scale_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrc, \fBq31_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "\fIQ31 matrix scaling\&. \fP"
.ti -1c
.RI "void \fBarm_mat_init_q31\fP (\fBarm_matrix_instance_q31\fP *S, uint16_t nRows, uint16_t nColumns, \fBq31_t\fP *pData)"
.br
.RI "\fIQ31 matrix initialization\&. \fP"
.ti -1c
.RI "void \fBarm_mat_init_q15\fP (\fBarm_matrix_instance_q15\fP *S, uint16_t nRows, uint16_t nColumns, \fBq15_t\fP *pData)"
.br
.RI "\fIQ15 matrix initialization\&. \fP"
.ti -1c
.RI "void \fBarm_mat_init_f32\fP (\fBarm_matrix_instance_f32\fP *S, uint16_t nRows, uint16_t nColumns, \fBfloat32_t\fP *pData)"
.br
.RI "\fIFloating-point matrix initialization\&. \fP"
.ti -1c
.RI "void \fBarm_pid_init_f32\fP (\fBarm_pid_instance_f32\fP *S, int32_t resetStateFlag)"
.br
.RI "\fIInitialization function for the floating-point PID Control\&. \fP"
.ti -1c
.RI "void \fBarm_pid_reset_f32\fP (\fBarm_pid_instance_f32\fP *S)"
.br
.RI "\fIReset function for the floating-point PID Control\&. \fP"
.ti -1c
.RI "void \fBarm_pid_init_q31\fP (\fBarm_pid_instance_q31\fP *S, int32_t resetStateFlag)"
.br
.RI "\fIInitialization function for the Q31 PID Control\&. \fP"
.ti -1c
.RI "void \fBarm_pid_reset_q31\fP (\fBarm_pid_instance_q31\fP *S)"
.br
.RI "\fIReset function for the Q31 PID Control\&. \fP"
.ti -1c
.RI "void \fBarm_pid_init_q15\fP (\fBarm_pid_instance_q15\fP *S, int32_t resetStateFlag)"
.br
.RI "\fIInitialization function for the Q15 PID Control\&. \fP"
.ti -1c
.RI "void \fBarm_pid_reset_q15\fP (\fBarm_pid_instance_q15\fP *S)"
.br
.RI "\fIReset function for the Q15 PID Control\&. \fP"
.ti -1c
.RI "void \fBarm_mult_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ7 vector multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_mult_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ15 vector multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_mult_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ31 vector multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_mult_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFloating-point vector multiplication\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix2_init_q15\fP (\fBarm_cfft_radix2_instance_q15\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix2_q15\fP (const \fBarm_cfft_radix2_instance_q15\fP *S, \fBq15_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix4_init_q15\fP (\fBarm_cfft_radix4_instance_q15\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix4_q15\fP (const \fBarm_cfft_radix4_instance_q15\fP *S, \fBq15_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix2_init_q31\fP (\fBarm_cfft_radix2_instance_q31\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix2_q31\fP (const \fBarm_cfft_radix2_instance_q31\fP *S, \fBq31_t\fP *pSrc)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix4_q31\fP (const \fBarm_cfft_radix4_instance_q31\fP *S, \fBq31_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix4_init_q31\fP (\fBarm_cfft_radix4_instance_q31\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix2_init_f32\fP (\fBarm_cfft_radix2_instance_f32\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix2_f32\fP (const \fBarm_cfft_radix2_instance_f32\fP *S, \fBfloat32_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix4_init_f32\fP (\fBarm_cfft_radix4_instance_f32\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix4_f32\fP (const \fBarm_cfft_radix4_instance_f32\fP *S, \fBfloat32_t\fP *pSrc)"
.br
.ti -1c
.RI "void \fBarm_cfft_f32\fP (const \fBarm_cfft_instance_f32\fP *S, \fBfloat32_t\fP *p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_init_q15\fP (\fBarm_rfft_instance_q15\fP *S, \fBarm_cfft_radix4_instance_q15\fP *S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_rfft_q15\fP (const \fBarm_rfft_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_init_q31\fP (\fBarm_rfft_instance_q31\fP *S, \fBarm_cfft_radix4_instance_q31\fP *S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_rfft_q31\fP (const \fBarm_rfft_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_init_f32\fP (\fBarm_rfft_instance_f32\fP *S, \fBarm_cfft_radix4_instance_f32\fP *S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_rfft_f32\fP (const \fBarm_rfft_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_fast_init_f32\fP (\fBarm_rfft_fast_instance_f32\fP *S, uint16_t fftLen)"
.br
.ti -1c
.RI "void \fBarm_rfft_fast_f32\fP (\fBarm_rfft_fast_instance_f32\fP *S, \fBfloat32_t\fP *p, \fBfloat32_t\fP *pOut, uint8_t ifftFlag)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_dct4_init_f32\fP (\fBarm_dct4_instance_f32\fP *S, \fBarm_rfft_instance_f32\fP *S_RFFT, \fBarm_cfft_radix4_instance_f32\fP *S_CFFT, uint16_t N, uint16_t Nby2, \fBfloat32_t\fP normalize)"
.br
.RI "\fIInitialization function for the floating-point DCT4/IDCT4\&. \fP"
.ti -1c
.RI "void \fBarm_dct4_f32\fP (const \fBarm_dct4_instance_f32\fP *S, \fBfloat32_t\fP *pState, \fBfloat32_t\fP *pInlineBuffer)"
.br
.RI "\fIProcessing function for the floating-point DCT4/IDCT4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_dct4_init_q31\fP (\fBarm_dct4_instance_q31\fP *S, \fBarm_rfft_instance_q31\fP *S_RFFT, \fBarm_cfft_radix4_instance_q31\fP *S_CFFT, uint16_t N, uint16_t Nby2, \fBq31_t\fP normalize)"
.br
.RI "\fIInitialization function for the Q31 DCT4/IDCT4\&. \fP"
.ti -1c
.RI "void \fBarm_dct4_q31\fP (const \fBarm_dct4_instance_q31\fP *S, \fBq31_t\fP *pState, \fBq31_t\fP *pInlineBuffer)"
.br
.RI "\fIProcessing function for the Q31 DCT4/IDCT4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_dct4_init_q15\fP (\fBarm_dct4_instance_q15\fP *S, \fBarm_rfft_instance_q15\fP *S_RFFT, \fBarm_cfft_radix4_instance_q15\fP *S_CFFT, uint16_t N, uint16_t Nby2, \fBq15_t\fP normalize)"
.br
.RI "\fIInitialization function for the Q15 DCT4/IDCT4\&. \fP"
.ti -1c
.RI "void \fBarm_dct4_q15\fP (const \fBarm_dct4_instance_q15\fP *S, \fBq15_t\fP *pState, \fBq15_t\fP *pInlineBuffer)"
.br
.RI "\fIProcessing function for the Q15 DCT4/IDCT4\&. \fP"
.ti -1c
.RI "void \fBarm_add_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFloating-point vector addition\&. \fP"
.ti -1c
.RI "void \fBarm_add_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ7 vector addition\&. \fP"
.ti -1c
.RI "void \fBarm_add_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ15 vector addition\&. \fP"
.ti -1c
.RI "void \fBarm_add_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ31 vector addition\&. \fP"
.ti -1c
.RI "void \fBarm_sub_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFloating-point vector subtraction\&. \fP"
.ti -1c
.RI "void \fBarm_sub_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ7 vector subtraction\&. \fP"
.ti -1c
.RI "void \fBarm_sub_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ15 vector subtraction\&. \fP"
.ti -1c
.RI "void \fBarm_sub_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ31 vector subtraction\&. \fP"
.ti -1c
.RI "void \fBarm_scale_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP scale, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIMultiplies a floating-point vector by a scalar\&. \fP"
.ti -1c
.RI "void \fBarm_scale_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP scaleFract, int8_t shift, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIMultiplies a Q7 vector by a scalar\&. \fP"
.ti -1c
.RI "void \fBarm_scale_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP scaleFract, int8_t shift, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIMultiplies a Q15 vector by a scalar\&. \fP"
.ti -1c
.RI "void \fBarm_scale_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP scaleFract, int8_t shift, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIMultiplies a Q31 vector by a scalar\&. \fP"
.ti -1c
.RI "void \fBarm_abs_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ7 vector absolute value\&. \fP"
.ti -1c
.RI "void \fBarm_abs_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFloating-point vector absolute value\&. \fP"
.ti -1c
.RI "void \fBarm_abs_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ15 vector absolute value\&. \fP"
.ti -1c
.RI "void \fBarm_abs_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIQ31 vector absolute value\&. \fP"
.ti -1c
.RI "void \fBarm_dot_prod_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, uint32_t blockSize, \fBfloat32_t\fP *result)"
.br
.RI "\fIDot product of floating-point vectors\&. \fP"
.ti -1c
.RI "void \fBarm_dot_prod_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, uint32_t blockSize, \fBq31_t\fP *result)"
.br
.RI "\fIDot product of Q7 vectors\&. \fP"
.ti -1c
.RI "void \fBarm_dot_prod_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, uint32_t blockSize, \fBq63_t\fP *result)"
.br
.RI "\fIDot product of Q15 vectors\&. \fP"
.ti -1c
.RI "void \fBarm_dot_prod_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, uint32_t blockSize, \fBq63_t\fP *result)"
.br
.RI "\fIDot product of Q31 vectors\&. \fP"
.ti -1c
.RI "void \fBarm_shift_q7\fP (\fBq7_t\fP *pSrc, int8_t shiftBits, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIShifts the elements of a Q7 vector a specified number of bits\&. \fP"
.ti -1c
.RI "void \fBarm_shift_q15\fP (\fBq15_t\fP *pSrc, int8_t shiftBits, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIShifts the elements of a Q15 vector a specified number of bits\&. \fP"
.ti -1c
.RI "void \fBarm_shift_q31\fP (\fBq31_t\fP *pSrc, int8_t shiftBits, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIShifts the elements of a Q31 vector a specified number of bits\&. \fP"
.ti -1c
.RI "void \fBarm_offset_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP offset, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIAdds a constant offset to a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_offset_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP offset, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIAdds a constant offset to a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_offset_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP offset, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIAdds a constant offset to a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_offset_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP offset, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIAdds a constant offset to a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_negate_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fINegates the elements of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_negate_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fINegates the elements of a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_negate_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fINegates the elements of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_negate_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fINegates the elements of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_copy_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fICopies the elements of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_copy_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fICopies the elements of a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_copy_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fICopies the elements of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_copy_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fICopies the elements of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_fill_f32\fP (\fBfloat32_t\fP value, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFills a constant value into a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_fill_q7\fP (\fBq7_t\fP value, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFills a constant value into a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_fill_q15\fP (\fBq15_t\fP value, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFills a constant value into a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_fill_q31\fP (\fBq31_t\fP value, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIFills a constant value into a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_conv_f32\fP (\fBfloat32_t\fP *pSrcA, uint32_t srcALen, \fBfloat32_t\fP *pSrcB, uint32_t srcBLen, \fBfloat32_t\fP *pDst)"
.br
.RI "\fIConvolution of floating-point sequences\&. \fP"
.ti -1c
.RI "void \fBarm_conv_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fIConvolution of Q15 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_conv_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "\fIConvolution of Q15 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_conv_fast_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "\fIConvolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_conv_fast_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fIConvolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_conv_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "\fIConvolution of Q31 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_conv_fast_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "\fIConvolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_conv_opt_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fIConvolution of Q7 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_conv_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst)"
.br
.RI "\fIConvolution of Q7 sequences\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_f32\fP (\fBfloat32_t\fP *pSrcA, uint32_t srcALen, \fBfloat32_t\fP *pSrcB, uint32_t srcBLen, \fBfloat32_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "\fIPartial convolution of floating-point sequences\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fIPartial convolution of Q15 sequences\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "\fIPartial convolution of Q15 sequences\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_fast_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "\fIPartial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_fast_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fIPartial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "\fIPartial convolution of Q31 sequences\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_fast_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "\fIPartial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_opt_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fIPartial convolution of Q7 sequences\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "\fIPartial convolution of Q7 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_fir_decimate_f32\fP (const \fBarm_fir_decimate_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point FIR decimator\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_decimate_init_f32\fP (\fBarm_fir_decimate_instance_f32\fP *S, uint16_t numTaps, uint8_t M, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the floating-point FIR decimator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_decimate_q15\fP (const \fBarm_fir_decimate_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 FIR decimator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_decimate_fast_q15\fP (const \fBarm_fir_decimate_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_decimate_init_q15\fP (\fBarm_fir_decimate_instance_q15\fP *S, uint16_t numTaps, uint8_t M, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q15 FIR decimator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_decimate_q31\fP (const \fBarm_fir_decimate_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 FIR decimator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_decimate_fast_q31\fP (\fBarm_fir_decimate_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_decimate_init_q31\fP (\fBarm_fir_decimate_instance_q31\fP *S, uint16_t numTaps, uint8_t M, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q31 FIR decimator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_interpolate_q15\fP (const \fBarm_fir_interpolate_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 FIR interpolator\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_interpolate_init_q15\fP (\fBarm_fir_interpolate_instance_q15\fP *S, uint8_t L, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q15 FIR interpolator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_interpolate_q31\fP (const \fBarm_fir_interpolate_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 FIR interpolator\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_interpolate_init_q31\fP (\fBarm_fir_interpolate_instance_q31\fP *S, uint8_t L, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q31 FIR interpolator\&. \fP"
.ti -1c
.RI "void \fBarm_fir_interpolate_f32\fP (const \fBarm_fir_interpolate_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point FIR interpolator\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_interpolate_init_f32\fP (\fBarm_fir_interpolate_instance_f32\fP *S, uint8_t L, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the floating-point FIR interpolator\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cas_df1_32x64_q31\fP (const \fBarm_biquad_cas_df1_32x64_ins_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.ti -1c
.RI "void \fBarm_biquad_cas_df1_32x64_init_q31\fP (\fBarm_biquad_cas_df1_32x64_ins_q31\fP *S, uint8_t numStages, \fBq31_t\fP *pCoeffs, \fBq63_t\fP *pState, uint8_t postShift)"
.br
.ti -1c
.RI "void \fBarm_biquad_cascade_df2T_f32\fP (const \fBarm_biquad_cascade_df2T_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point transposed direct form II Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_biquad_cascade_df2T_init_f32\fP (\fBarm_biquad_cascade_df2T_instance_f32\fP *S, uint8_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "\fIInitialization function for the floating-point transposed direct form II Biquad cascade filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_lattice_init_q15\fP (\fBarm_fir_lattice_instance_q15\fP *S, uint16_t numStages, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState)"
.br
.RI "\fIInitialization function for the Q15 FIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_lattice_q15\fP (const \fBarm_fir_lattice_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 FIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_lattice_init_q31\fP (\fBarm_fir_lattice_instance_q31\fP *S, uint16_t numStages, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState)"
.br
.RI "\fIInitialization function for the Q31 FIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_lattice_q31\fP (const \fBarm_fir_lattice_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 FIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_lattice_init_f32\fP (\fBarm_fir_lattice_instance_f32\fP *S, uint16_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "\fIInitialization function for the floating-point FIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_lattice_f32\fP (const \fBarm_fir_lattice_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point FIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_iir_lattice_f32\fP (const \fBarm_iir_lattice_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point IIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_iir_lattice_init_f32\fP (\fBarm_iir_lattice_instance_f32\fP *S, uint16_t numStages, \fBfloat32_t\fP *pkCoeffs, \fBfloat32_t\fP *pvCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the floating-point IIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_iir_lattice_q31\fP (const \fBarm_iir_lattice_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 IIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_iir_lattice_init_q31\fP (\fBarm_iir_lattice_instance_q31\fP *S, uint16_t numStages, \fBq31_t\fP *pkCoeffs, \fBq31_t\fP *pvCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q31 IIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_iir_lattice_q15\fP (const \fBarm_iir_lattice_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 IIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_iir_lattice_init_q15\fP (\fBarm_iir_lattice_instance_q15\fP *S, uint16_t numStages, \fBq15_t\fP *pkCoeffs, \fBq15_t\fP *pvCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q15 IIR lattice filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_f32\fP (const \fBarm_lms_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pRef, \fBfloat32_t\fP *pOut, \fBfloat32_t\fP *pErr, uint32_t blockSize)"
.br
.RI "\fIProcessing function for floating-point LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_init_f32\fP (\fBarm_lms_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, \fBfloat32_t\fP mu, uint32_t blockSize)"
.br
.RI "\fIInitialization function for floating-point LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_init_q15\fP (\fBarm_lms_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, \fBq15_t\fP mu, uint32_t blockSize, uint32_t postShift)"
.br
.RI "\fIInitialization function for the Q15 LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_q15\fP (const \fBarm_lms_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pRef, \fBq15_t\fP *pOut, \fBq15_t\fP *pErr, uint32_t blockSize)"
.br
.RI "\fIProcessing function for Q15 LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_q31\fP (const \fBarm_lms_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pRef, \fBq31_t\fP *pOut, \fBq31_t\fP *pErr, uint32_t blockSize)"
.br
.RI "\fIProcessing function for Q31 LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_init_q31\fP (\fBarm_lms_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, \fBq31_t\fP mu, uint32_t blockSize, uint32_t postShift)"
.br
.RI "\fIInitialization function for Q31 LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_norm_f32\fP (\fBarm_lms_norm_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pRef, \fBfloat32_t\fP *pOut, \fBfloat32_t\fP *pErr, uint32_t blockSize)"
.br
.RI "\fIProcessing function for floating-point normalized LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_norm_init_f32\fP (\fBarm_lms_norm_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, \fBfloat32_t\fP mu, uint32_t blockSize)"
.br
.RI "\fIInitialization function for floating-point normalized LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_norm_q31\fP (\fBarm_lms_norm_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pRef, \fBq31_t\fP *pOut, \fBq31_t\fP *pErr, uint32_t blockSize)"
.br
.RI "\fIProcessing function for Q31 normalized LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_norm_init_q31\fP (\fBarm_lms_norm_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, \fBq31_t\fP mu, uint32_t blockSize, uint8_t postShift)"
.br
.RI "\fIInitialization function for Q31 normalized LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_norm_q15\fP (\fBarm_lms_norm_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pRef, \fBq15_t\fP *pOut, \fBq15_t\fP *pErr, uint32_t blockSize)"
.br
.RI "\fIProcessing function for Q15 normalized LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_lms_norm_init_q15\fP (\fBarm_lms_norm_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, \fBq15_t\fP mu, uint32_t blockSize, uint8_t postShift)"
.br
.RI "\fIInitialization function for Q15 normalized LMS filter\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_f32\fP (\fBfloat32_t\fP *pSrcA, uint32_t srcALen, \fBfloat32_t\fP *pSrcB, uint32_t srcBLen, \fBfloat32_t\fP *pDst)"
.br
.RI "\fICorrelation of floating-point sequences\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch)"
.br
.RI "\fICorrelation of Q15 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "\fICorrelation of Q15 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_fast_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "\fICorrelation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_fast_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch)"
.br
.RI "\fICorrelation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "\fICorrelation of Q31 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_fast_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "\fICorrelation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_opt_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "\fICorrelation of Q7 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_correlate_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst)"
.br
.RI "\fICorrelation of Q7 sequences\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_f32\fP (\fBarm_fir_sparse_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, \fBfloat32_t\fP *pScratchIn, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the floating-point sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_init_f32\fP (\fBarm_fir_sparse_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the floating-point sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_q31\fP (\fBarm_fir_sparse_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, \fBq31_t\fP *pScratchIn, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q31 sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_init_q31\fP (\fBarm_fir_sparse_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q31 sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_q15\fP (\fBarm_fir_sparse_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratchIn, \fBq31_t\fP *pScratchOut, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q15 sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_init_q15\fP (\fBarm_fir_sparse_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q15 sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_q7\fP (\fBarm_fir_sparse_instance_q7\fP *S, \fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, \fBq7_t\fP *pScratchIn, \fBq31_t\fP *pScratchOut, uint32_t blockSize)"
.br
.RI "\fIProcessing function for the Q7 sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_fir_sparse_init_q7\fP (\fBarm_fir_sparse_instance_q7\fP *S, uint16_t numTaps, \fBq7_t\fP *pCoeffs, \fBq7_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "\fIInitialization function for the Q7 sparse FIR filter\&. \fP"
.ti -1c
.RI "void \fBarm_sin_cos_f32\fP (\fBfloat32_t\fP theta, \fBfloat32_t\fP *pSinVal, \fBfloat32_t\fP *pCcosVal)"
.br
.ti -1c
.RI "void \fBarm_sin_cos_q31\fP (\fBq31_t\fP theta, \fBq31_t\fP *pSinVal, \fBq31_t\fP *pCosVal)"
.br
.ti -1c
.RI "void \fBarm_cmplx_conj_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIFloating-point complex conjugate\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_conj_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ31 complex conjugate\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_conj_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ15 complex conjugate\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mag_squared_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIFloating-point complex magnitude squared\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mag_squared_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ31 complex magnitude squared\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mag_squared_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ15 complex magnitude squared\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_inverse_f32\fP (const \fBarm_matrix_instance_f32\fP *src, \fBarm_matrix_instance_f32\fP *dst)"
.br
.RI "\fIFloating-point matrix inverse\&. \fP"
.ti -1c
.RI "void \fBarm_q7_to_q31\fP (\fBq7_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q7 vector to Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_q7_to_q15\fP (\fBq7_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q7 vector to Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_q7_to_float\fP (\fBq7_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q7 vector to floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_q31_to_float\fP (\fBq31_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q31 vector to floating-point vector\&. \fP"
.ti -1c
.RI "\fBfloat32_t\fP \fBarm_sin_f32\fP (\fBfloat32_t\fP x)"
.br
.RI "\fIFast approximation to the trigonometric sine function for floating-point data\&. \fP"
.ti -1c
.RI "\fBq31_t\fP \fBarm_sin_q31\fP (\fBq31_t\fP x)"
.br
.RI "\fIFast approximation to the trigonometric sine function for Q31 data\&. \fP"
.ti -1c
.RI "\fBq15_t\fP \fBarm_sin_q15\fP (\fBq15_t\fP x)"
.br
.RI "\fIFast approximation to the trigonometric sine function for Q15 data\&. \fP"
.ti -1c
.RI "\fBfloat32_t\fP \fBarm_cos_f32\fP (\fBfloat32_t\fP x)"
.br
.RI "\fIFast approximation to the trigonometric cosine function for floating-point data\&. \fP"
.ti -1c
.RI "\fBq31_t\fP \fBarm_cos_q31\fP (\fBq31_t\fP x)"
.br
.RI "\fIFast approximation to the trigonometric cosine function for Q31 data\&. \fP"
.ti -1c
.RI "\fBq15_t\fP \fBarm_cos_q15\fP (\fBq15_t\fP x)"
.br
.RI "\fIFast approximation to the trigonometric cosine function for Q15 data\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_sqrt_q31\fP (\fBq31_t\fP in, \fBq31_t\fP *pOut)"
.br
.RI "\fIQ31 square root function\&. \fP"
.ti -1c
.RI "\fBarm_status\fP \fBarm_sqrt_q15\fP (\fBq15_t\fP in, \fBq15_t\fP *pOut)"
.br
.RI "\fIQ15 square root function\&. \fP"
.ti -1c
.RI "void \fBarm_power_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq63_t\fP *pResult)"
.br
.RI "\fISum of the squares of the elements of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_power_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "\fISum of the squares of the elements of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_power_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq63_t\fP *pResult)"
.br
.RI "\fISum of the squares of the elements of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_power_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "\fISum of the squares of the elements of a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_mean_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq7_t\fP *pResult)"
.br
.RI "\fIMean value of a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_mean_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "\fIMean value of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_mean_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "\fIMean value of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_mean_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "\fIMean value of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_var_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "\fIVariance of the elements of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_var_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq63_t\fP *pResult)"
.br
.RI "\fIVariance of the elements of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_var_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "\fIVariance of the elements of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_rms_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "\fIRoot Mean Square of the elements of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_rms_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "\fIRoot Mean Square of the elements of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_rms_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "\fIRoot Mean Square of the elements of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_std_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "\fIStandard deviation of the elements of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_std_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "\fIStandard deviation of the elements of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_std_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "\fIStandard deviation of the elements of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mag_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIFloating-point complex magnitude\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mag_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ31 complex magnitude\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mag_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ15 complex magnitude\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_dot_prod_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, uint32_t numSamples, \fBq31_t\fP *realResult, \fBq31_t\fP *imagResult)"
.br
.RI "\fIQ15 complex dot product\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_dot_prod_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, uint32_t numSamples, \fBq63_t\fP *realResult, \fBq63_t\fP *imagResult)"
.br
.RI "\fIQ31 complex dot product\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_dot_prod_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, uint32_t numSamples, \fBfloat32_t\fP *realResult, \fBfloat32_t\fP *imagResult)"
.br
.RI "\fIFloating-point complex dot product\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mult_real_q15\fP (\fBq15_t\fP *pSrcCmplx, \fBq15_t\fP *pSrcReal, \fBq15_t\fP *pCmplxDst, uint32_t numSamples)"
.br
.RI "\fIQ15 complex-by-real multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mult_real_q31\fP (\fBq31_t\fP *pSrcCmplx, \fBq31_t\fP *pSrcReal, \fBq31_t\fP *pCmplxDst, uint32_t numSamples)"
.br
.RI "\fIQ31 complex-by-real multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mult_real_f32\fP (\fBfloat32_t\fP *pSrcCmplx, \fBfloat32_t\fP *pSrcReal, \fBfloat32_t\fP *pCmplxDst, uint32_t numSamples)"
.br
.RI "\fIFloating-point complex-by-real multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_min_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq7_t\fP *result, uint32_t *index)"
.br
.RI "\fIMinimum value of a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_min_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMinimum value of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_min_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMinimum value of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_min_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMinimum value of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_max_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq7_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMaximum value of a Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_max_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMaximum value of a Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_max_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMaximum value of a Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_max_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "\fIMaximum value of a floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mult_cmplx_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ15 complex-by-complex multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mult_cmplx_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIQ31 complex-by-complex multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_cmplx_mult_cmplx_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "\fIFloating-point complex-by-complex multiplication\&. \fP"
.ti -1c
.RI "void \fBarm_float_to_q31\fP (\fBfloat32_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the floating-point vector to Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_float_to_q15\fP (\fBfloat32_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the floating-point vector to Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_float_to_q7\fP (\fBfloat32_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the floating-point vector to Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_q31_to_q15\fP (\fBq31_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q31 vector to Q15 vector\&. \fP"
.ti -1c
.RI "void \fBarm_q31_to_q7\fP (\fBq31_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q31 vector to Q7 vector\&. \fP"
.ti -1c
.RI "void \fBarm_q15_to_float\fP (\fBq15_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q15 vector to floating-point vector\&. \fP"
.ti -1c
.RI "void \fBarm_q15_to_q31\fP (\fBq15_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q15 vector to Q31 vector\&. \fP"
.ti -1c
.RI "void \fBarm_q15_to_q7\fP (\fBq15_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "\fIConverts the elements of the Q15 vector to Q7 vector\&. \fP"
.in -1c
.SH "Documentacin de los 'defines'"
.PP 
.SS "#define __CMSIS_GENERIC   /* disable \fBNVIC\fP and Systick functions */"

.PP
Definicin en la lnea 267 del archivo arm_math\&.h\&.
.SS "#define __PACKq7(v0, v1, v2, v3)"
\fBValor:\fP
.PP
.nf
( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |    \
                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
                                (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
                                (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
.fi
.PP
definition to pack four 8 bit values\&. 
.PP
Definicin en la lnea 417 del archivo arm_math\&.h\&.
.SS "#define __SIMD32(addr)   (*(__SIMD32_TYPE **) & (addr))"

.PP
definition to read/write two 16 bit values\&. 
.PP
Definicin en la lnea 393 del archivo arm_math\&.h\&.
.SS "#define __SIMD32_CONST(addr)   ((__SIMD32_TYPE *)(addr))"

.PP
Definicin en la lnea 394 del archivo arm_math\&.h\&.
.SS "#define __SIMD64(addr)   (*(int64_t **) & (addr))"

.PP
Definicin en la lnea 398 del archivo arm_math\&.h\&.
.SS "#define _SIMD32_OFFSET(addr)   (*(__SIMD32_TYPE *)  (addr))"

.PP
Definicin en la lnea 396 del archivo arm_math\&.h\&.
.SS "#define ALIGN4"

.PP
Macro for Unaligned Support\&. 
.PP
Definicin en la lnea 323 del archivo arm_math\&.h\&.
.SS "#define DELTA_Q15   0x5"

.PP
Definicin en la lnea 298 del archivo arm_math\&.h\&.
.SS "#define DELTA_Q31   (0x100)"

.PP
Macros required for reciprocal calculation in Normalized LMS\&. 
.PP
Definicin en la lnea 297 del archivo arm_math\&.h\&.
.SS "#define INDEX_MASK   0x0000003F"

.PP
Definicin en la lnea 299 del archivo arm_math\&.h\&.
.SS "#define INPUT_SPACING   0xB60B61"

.PP
Macros required for SINE and COSINE Controller functions\&. 
.PP
Definicin en la lnea 317 del archivo arm_math\&.h\&.
.SS "#define PI   3\&.14159265358979f"

.PP
Definicin en la lnea 301 del archivo arm_math\&.h\&.
.SS "#define TABLE_SIZE   256"

.PP
Macros required for SINE and COSINE Fast math approximations\&. 
.PP
Definicin en la lnea 308 del archivo arm_math\&.h\&.
.SS "#define TABLE_SPACING_Q15   0x80"

.PP
Definicin en la lnea 310 del archivo arm_math\&.h\&.
.SS "#define TABLE_SPACING_Q31   0x800000"

.PP
Definicin en la lnea 309 del archivo arm_math\&.h\&.
.SH "Documentacin de los 'typedefs'"
.PP 
.SS "typedef float \fBfloat32_t\fP"

.PP
32-bit floating-point type definition\&. 
.PP
Definicin en la lnea 370 del archivo arm_math\&.h\&.
.SS "typedef double \fBfloat64_t\fP"

.PP
64-bit floating-point type definition\&. 
.PP
Definicin en la lnea 375 del archivo arm_math\&.h\&.
.SS "typedef int16_t \fBq15_t\fP"

.PP
16-bit fractional data type in 1\&.15 format\&. 
.PP
Definicin en la lnea 355 del archivo arm_math\&.h\&.
.SS "typedef int32_t \fBq31_t\fP"

.PP
32-bit fractional data type in 1\&.31 format\&. 
.PP
Definicin en la lnea 360 del archivo arm_math\&.h\&.
.SS "typedef int64_t \fBq63_t\fP"

.PP
64-bit fractional data type in 1\&.63 format\&. 
.PP
Definicin en la lnea 365 del archivo arm_math\&.h\&.
.SS "typedef int8_t \fBq7_t\fP"

.PP
8-bit fractional data type in 1\&.7 format\&. 
.PP
Definicin en la lnea 350 del archivo arm_math\&.h\&.
.SH "Documentacin de las enumeraciones"
.PP 
.SS "enum \fBarm_status\fP"

.PP
Error status returned by some functions in the library\&. 
.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIARM_MATH_SUCCESS \fP\fP
No error 
.TP
\fB\fIARM_MATH_ARGUMENT_ERROR \fP\fP
One or more arguments are incorrect 
.TP
\fB\fIARM_MATH_LENGTH_ERROR \fP\fP
Length of data buffer is incorrect 
.TP
\fB\fIARM_MATH_SIZE_MISMATCH \fP\fP
Size of matrices is not compatible with the operation\&. 
.TP
\fB\fIARM_MATH_NANINF \fP\fP
Not-a-number (NaN) or infinity is generated 
.TP
\fB\fIARM_MATH_SINGULAR \fP\fP
Generated by matrix inversion if the input matrix is singular and cannot be inverted\&. 
.TP
\fB\fIARM_MATH_TEST_FAILURE \fP\fP
Test Failed 
.PP
Definicin en la lnea 336 del archivo arm_math\&.h\&.
.SH "Documentacin de las funciones"
.PP 
.SS "void arm_abs_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector absolute value\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fI*pDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_abs_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector absolute value\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fI*pDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_abs_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector absolute value\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fI*pDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_abs_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector absolute value\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fI*pDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_add_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_add_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_add_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_add_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cas_df1_32x64_init_q31 (\fBarm_biquad_cas_df1_32x64_ins_q31\fP * S, uint8_t numStages, \fBq31_t\fP * pCoeffs, \fBq63_t\fP * pState, uint8_t postShift)"

.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the high precision Q31 Biquad cascade filter structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIpostShift\fP shift to be applied to the output\&. Varies according to the coefficients format 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_biquad_cas_df1_32x64_q31 (const \fBarm_biquad_cas_df1_32x64_ins_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the high precision Q31 Biquad cascade filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_f32 (const \fBarm_biquad_casd_df1_inst_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point Biquad cascade structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_fast_q15 (const \fBarm_biquad_casd_df1_inst_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 Biquad cascade structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_fast_q31 (const \fBarm_biquad_casd_df1_inst_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 Biquad cascade structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_init_f32 (\fBarm_biquad_casd_df1_inst_f32\fP * S, uint8_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point Biquad cascade structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_biquad_cascade_df1_init_q15 (\fBarm_biquad_casd_df1_inst_q15\fP * S, uint8_t numStages, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, int8_t postShift)"

.PP
Initialization function for the Q15 Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 Biquad cascade structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIpostShift\fP Shift to be applied to the output\&. Varies according to the coefficients format 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_biquad_cascade_df1_init_q31 (\fBarm_biquad_casd_df1_inst_q31\fP * S, uint8_t numStages, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, int8_t postShift)"

.PP
Initialization function for the Q31 Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 Biquad cascade structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIpostShift\fP Shift to be applied to the output\&. Varies according to the coefficients format 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_biquad_cascade_df1_q15 (const \fBarm_biquad_casd_df1_inst_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 Biquad cascade structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_q31 (const \fBarm_biquad_casd_df1_inst_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 Biquad cascade structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df2T_f32 (const \fBarm_biquad_cascade_df2T_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the filter data structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df2T_init_f32 (\fBarm_biquad_cascade_df2T_instance_f32\fP * S, uint8_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the filter data structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_cfft_f32 (const \fBarm_cfft_instance_f32\fP * S, \fBfloat32_t\fP * p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_radix2_f32 (const \fBarm_cfft_radix2_instance_f32\fP * S, \fBfloat32_t\fP * pSrc)"

.SS "\fBarm_status\fP arm_cfft_radix2_init_f32 (\fBarm_cfft_radix2_instance_f32\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix2_init_q15 (\fBarm_cfft_radix2_instance_q15\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix2_init_q31 (\fBarm_cfft_radix2_instance_q31\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_radix2_q15 (const \fBarm_cfft_radix2_instance_q15\fP * S, \fBq15_t\fP * pSrc)"

.SS "void arm_cfft_radix2_q31 (const \fBarm_cfft_radix2_instance_q31\fP * S, \fBq31_t\fP * pSrc)"

.SS "void arm_cfft_radix4_f32 (const \fBarm_cfft_radix4_instance_f32\fP * S, \fBfloat32_t\fP * pSrc)"

.SS "\fBarm_status\fP arm_cfft_radix4_init_f32 (\fBarm_cfft_radix4_instance_f32\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix4_init_q15 (\fBarm_cfft_radix4_instance_q15\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix4_init_q31 (\fBarm_cfft_radix4_instance_q31\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_radix4_q15 (const \fBarm_cfft_radix4_instance_q15\fP * S, \fBq15_t\fP * pSrc)"

.SS "void arm_cfft_radix4_q31 (const \fBarm_cfft_radix4_instance_q31\fP * S, \fBq31_t\fP * pSrc)"

.SS "void arm_cmplx_conj_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex conjugate\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_conj_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex conjugate\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_conj_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex conjugate\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_dot_prod_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, uint32_t numSamples, \fBfloat32_t\fP * realResult, \fBfloat32_t\fP * imagResult)"

.PP
Floating-point complex dot product\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.br
\fI*realResult\fP real part of the result returned here 
.br
\fI*imagResult\fP imaginary part of the result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_dot_prod_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, uint32_t numSamples, \fBq31_t\fP * realResult, \fBq31_t\fP * imagResult)"

.PP
Q15 complex dot product\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.br
\fI*realResult\fP real part of the result returned here 
.br
\fI*imagResult\fP imaginary part of the result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_dot_prod_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, uint32_t numSamples, \fBq63_t\fP * realResult, \fBq63_t\fP * imagResult)"

.PP
Q31 complex dot product\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.br
\fI*realResult\fP real part of the result returned here 
.br
\fI*imagResult\fP imaginary part of the result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mag_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex magnitude\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the complex input vector 
.br
\fI*pDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mag_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex magnitude\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the complex input vector 
.br
\fI*pDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mag_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex magnitude\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the complex input vector 
.br
\fI*pDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mag_squared_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex magnitude squared\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the complex input vector 
.br
\fI*pDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mag_squared_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex magnitude squared\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the complex input vector 
.br
\fI*pDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mag_squared_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex magnitude squared\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the complex input vector 
.br
\fI*pDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mult_cmplx_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex-by-complex multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mult_cmplx_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex-by-complex multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mult_cmplx_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex-by-complex multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mult_real_f32 (\fBfloat32_t\fP * pSrcCmplx, \fBfloat32_t\fP * pSrcReal, \fBfloat32_t\fP * pCmplxDst, uint32_t numSamples)"

.PP
Floating-point complex-by-real multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcCmplx\fP points to the complex input vector 
.br
\fI*pSrcReal\fP points to the real input vector 
.br
\fI*pCmplxDst\fP points to the complex output vector 
.br
\fInumSamples\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mult_real_q15 (\fBq15_t\fP * pSrcCmplx, \fBq15_t\fP * pSrcReal, \fBq15_t\fP * pCmplxDst, uint32_t numSamples)"

.PP
Q15 complex-by-real multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcCmplx\fP points to the complex input vector 
.br
\fI*pSrcReal\fP points to the real input vector 
.br
\fI*pCmplxDst\fP points to the complex output vector 
.br
\fInumSamples\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_cmplx_mult_real_q31 (\fBq31_t\fP * pSrcCmplx, \fBq31_t\fP * pSrcReal, \fBq31_t\fP * pCmplxDst, uint32_t numSamples)"

.PP
Q31 complex-by-real multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcCmplx\fP points to the complex input vector 
.br
\fI*pSrcReal\fP points to the real input vector 
.br
\fI*pCmplxDst\fP points to the complex output vector 
.br
\fInumSamples\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_f32 (\fBfloat32_t\fP * pSrcA, uint32_t srcALen, \fBfloat32_t\fP * pSrcB, uint32_t srcBLen, \fBfloat32_t\fP * pDst)"

.PP
Convolution of floating-point sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the location where the output result is written\&. Length srcALen+srcBLen-1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_fast_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.br
\fI*pScratch1\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*pScratch2\fP points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_fast_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_fast_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Convolution of Q15 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.br
\fI*pScratch1\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*pScratch2\fP points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_opt_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Convolution of Q7 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.br
\fI*pScratch1\fP points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*pScratch2\fP points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_f32 (\fBfloat32_t\fP * pSrcA, uint32_t srcALen, \fBfloat32_t\fP * pSrcB, uint32_t srcBLen, \fBfloat32_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of floating-point sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_fast_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.br
\fI*\fP pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*\fP pScratch2 points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_fast_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_fast_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Partial convolution of Q15 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.br
\fI*\fP pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*\fP pScratch2 points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_opt_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Partial convolution of Q7 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.br
\fI*pScratch1\fP points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*pScratch2\fP points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q15 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q31 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q7 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "void arm_conv_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Convolution of Q15 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the location where the output result is written\&. Length srcALen+srcBLen-1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Convolution of Q31 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_conv_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst)"

.PP
Convolution of Q7 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_copy_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP input pointer 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_copy_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP input pointer 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_copy_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP input pointer 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_copy_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP input pointer 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_f32 (\fBfloat32_t\fP * pSrcA, uint32_t srcALen, \fBfloat32_t\fP * pSrcB, uint32_t srcBLen, \fBfloat32_t\fP * pDst)"

.PP
Correlation of floating-point sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_fast_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch)"

.PP
Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.br
\fI*pScratch\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_fast_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_fast_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch)"

.PP
Correlation of Q15 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.br
\fI*pScratch\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_opt_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Correlation of Q7 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.br
\fI*pScratch1\fP points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fI*pScratch2\fP points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Correlation of Q15 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Correlation of Q31 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_correlate_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst)"

.PP
Correlation of Q7 sequences\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fI*pSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fI*pDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "\fBfloat32_t\fP arm_cos_f32 (\fBfloat32_t\fP x)"

.PP
Fast approximation to the trigonometric cosine function for floating-point data\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIx\fP input value in radians\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
cos(x)\&. 
.RE
.PP

.SS "\fBq15_t\fP arm_cos_q15 (\fBq15_t\fP x)"

.PP
Fast approximation to the trigonometric cosine function for Q15 data\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
cos(x)\&. 
.RE
.PP

.SS "\fBq31_t\fP arm_cos_q31 (\fBq31_t\fP x)"

.PP
Fast approximation to the trigonometric cosine function for Q31 data\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
cos(x)\&. 
.RE
.PP

.SS "void arm_dct4_f32 (const \fBarm_dct4_instance_f32\fP * S, \fBfloat32_t\fP * pState, \fBfloat32_t\fP * pInlineBuffer)"

.PP
Processing function for the floating-point DCT4/IDCT4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point DCT4/IDCT4 structure\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fI*pInlineBuffer\fP points to the in-place input and output buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_dct4_init_f32 (\fBarm_dct4_instance_f32\fP * S, \fBarm_rfft_instance_f32\fP * S_RFFT, \fBarm_cfft_radix4_instance_f32\fP * S_CFFT, uint16_t N, uint16_t Nby2, \fBfloat32_t\fP normalize)"

.PP
Initialization function for the floating-point DCT4/IDCT4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of floating-point DCT4/IDCT4 structure\&. 
.br
\fI*S_RFFT\fP points to an instance of floating-point RFFT/RIFFT structure\&. 
.br
\fI*S_CFFT\fP points to an instance of floating-point CFFT/CIFFT structure\&. 
.br
\fIN\fP length of the DCT4\&. 
.br
\fINby2\fP half of the length of the DCT4\&. 
.br
\fInormalize\fP normalizing factor\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if \fCfftLenReal\fP is not a supported transform length\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_dct4_init_q15 (\fBarm_dct4_instance_q15\fP * S, \fBarm_rfft_instance_q15\fP * S_RFFT, \fBarm_cfft_radix4_instance_q15\fP * S_CFFT, uint16_t N, uint16_t Nby2, \fBq15_t\fP normalize)"

.PP
Initialization function for the Q15 DCT4/IDCT4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of Q15 DCT4/IDCT4 structure\&. 
.br
\fI*S_RFFT\fP points to an instance of Q15 RFFT/RIFFT structure\&. 
.br
\fI*S_CFFT\fP points to an instance of Q15 CFFT/CIFFT structure\&. 
.br
\fIN\fP length of the DCT4\&. 
.br
\fINby2\fP half of the length of the DCT4\&. 
.br
\fInormalize\fP normalizing factor\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if \fCN\fP is not a supported transform length\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_dct4_init_q31 (\fBarm_dct4_instance_q31\fP * S, \fBarm_rfft_instance_q31\fP * S_RFFT, \fBarm_cfft_radix4_instance_q31\fP * S_CFFT, uint16_t N, uint16_t Nby2, \fBq31_t\fP normalize)"

.PP
Initialization function for the Q31 DCT4/IDCT4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of Q31 DCT4/IDCT4 structure\&. 
.br
\fI*S_RFFT\fP points to an instance of Q31 RFFT/RIFFT structure 
.br
\fI*S_CFFT\fP points to an instance of Q31 CFFT/CIFFT structure 
.br
\fIN\fP length of the DCT4\&. 
.br
\fINby2\fP half of the length of the DCT4\&. 
.br
\fInormalize\fP normalizing factor\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if \fCN\fP is not a supported transform length\&. 
.RE
.PP

.SS "void arm_dct4_q15 (const \fBarm_dct4_instance_q15\fP * S, \fBq15_t\fP * pState, \fBq15_t\fP * pInlineBuffer)"

.PP
Processing function for the Q15 DCT4/IDCT4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 DCT4 structure\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fI*pInlineBuffer\fP points to the in-place input and output buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_dct4_q31 (const \fBarm_dct4_instance_q31\fP * S, \fBq31_t\fP * pState, \fBq31_t\fP * pInlineBuffer)"

.PP
Processing function for the Q31 DCT4/IDCT4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 DCT4 structure\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fI*pInlineBuffer\fP points to the in-place input and output buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_dot_prod_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, uint32_t blockSize, \fBfloat32_t\fP * result)"

.PP
Dot product of floating-point vectors\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fI*result\fP output result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_dot_prod_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, uint32_t blockSize, \fBq63_t\fP * result)"

.PP
Dot product of Q15 vectors\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fI*result\fP output result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_dot_prod_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, uint32_t blockSize, \fBq63_t\fP * result)"

.PP
Dot product of Q31 vectors\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fI*result\fP output result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_dot_prod_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, uint32_t blockSize, \fBq31_t\fP * result)"

.PP
Dot product of Q7 vectors\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fI*result\fP output result returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fill_f32 (\fBfloat32_t\fP value, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fill_q15 (\fBq15_t\fP value, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fill_q31 (\fBq31_t\fP value, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fill_q7 (\fBq7_t\fP value, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_decimate_f32 (const \fBarm_fir_decimate_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR decimator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR decimator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_decimate_fast_q15 (const \fBarm_fir_decimate_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR decimator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_decimate_fast_q31 (\fBarm_fir_decimate_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR decimator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_decimate_init_f32 (\fBarm_fir_decimate_instance_f32\fP * S, uint16_t numTaps, uint8_t M, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point FIR decimator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR decimator structure\&. 
.br
\fInumTaps\fP number of coefficients in the filter\&. 
.br
\fIM\fP decimation factor\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if \fCblockSize\fP is not a multiple of \fCM\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_decimate_init_q15 (\fBarm_fir_decimate_instance_q15\fP * S, uint16_t numTaps, uint8_t M, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 FIR decimator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR decimator structure\&. 
.br
\fInumTaps\fP number of coefficients in the filter\&. 
.br
\fIM\fP decimation factor\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if \fCblockSize\fP is not a multiple of \fCM\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_decimate_init_q31 (\fBarm_fir_decimate_instance_q31\fP * S, uint16_t numTaps, uint8_t M, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 FIR decimator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR decimator structure\&. 
.br
\fInumTaps\fP number of coefficients in the filter\&. 
.br
\fIM\fP decimation factor\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if \fCblockSize\fP is not a multiple of \fCM\fP\&. 
.RE
.PP

.SS "void arm_fir_decimate_q15 (const \fBarm_fir_decimate_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR decimator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR decimator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_decimate_q31 (const \fBarm_fir_decimate_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR decimator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR decimator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_f32 (const \fBarm_fir_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_fast_q15 (const \fBarm_fir_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_fast_q31 (const \fBarm_fir_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_init_f32 (\fBarm_fir_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR filter structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed at a time\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_init_q15 (\fBarm_fir_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR filter structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. Must be even and greater than or equal to 4\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed at a time\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if \fCnumTaps\fP is not a supported value\&. 
.RE
.PP

.SS "void arm_fir_init_q31 (\fBarm_fir_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed at a time\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_init_q7 (\fBarm_fir_instance_q7\fP * S, uint16_t numTaps, \fBq7_t\fP * pCoeffs, \fBq7_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q7 FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q7 FIR structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_interpolate_f32 (const \fBarm_fir_interpolate_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR interpolator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR interpolator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_interpolate_init_f32 (\fBarm_fir_interpolate_instance_f32\fP * S, uint8_t L, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point FIR interpolator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR interpolator structure\&. 
.br
\fIL\fP upsample factor\&. 
.br
\fInumTaps\fP number of filter coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficient buffer\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if the filter length \fCnumTaps\fP is not a multiple of the interpolation factor \fCL\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_interpolate_init_q15 (\fBarm_fir_interpolate_instance_q15\fP * S, uint8_t L, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 FIR interpolator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR interpolator structure\&. 
.br
\fIL\fP upsample factor\&. 
.br
\fInumTaps\fP number of filter coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficient buffer\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if the filter length \fCnumTaps\fP is not a multiple of the interpolation factor \fCL\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_interpolate_init_q31 (\fBarm_fir_interpolate_instance_q31\fP * S, uint8_t L, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 FIR interpolator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR interpolator structure\&. 
.br
\fIL\fP upsample factor\&. 
.br
\fInumTaps\fP number of filter coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the filter coefficient buffer\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if the filter length \fCnumTaps\fP is not a multiple of the interpolation factor \fCL\fP\&. 
.RE
.PP

.SS "void arm_fir_interpolate_q15 (const \fBarm_fir_interpolate_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR interpolator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR interpolator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_interpolate_q31 (const \fBarm_fir_interpolate_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR interpolator\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR interpolator structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_lattice_f32 (const \fBarm_fir_lattice_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR lattice structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_lattice_init_f32 (\fBarm_fir_lattice_instance_f32\fP * S, uint16_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point FIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point FIR lattice structure\&. 
.br
\fInumStages\fP number of filter stages\&. 
.br
\fI*pCoeffs\fP points to the coefficient buffer\&. The array is of length numStages\&. 
.br
\fI*pState\fP points to the state buffer\&. The array is of length numStages\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_lattice_init_q15 (\fBarm_fir_lattice_instance_q15\fP * S, uint16_t numStages, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState)"

.PP
Initialization function for the Q15 FIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR lattice structure\&. 
.br
\fInumStages\fP number of filter stages\&. 
.br
\fI*pCoeffs\fP points to the coefficient buffer\&. The array is of length numStages\&. 
.br
\fI*pState\fP points to the state buffer\&. The array is of length numStages\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_lattice_init_q31 (\fBarm_fir_lattice_instance_q31\fP * S, uint16_t numStages, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState)"

.PP
Initialization function for the Q31 FIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR lattice structure\&. 
.br
\fInumStages\fP number of filter stages\&. 
.br
\fI*pCoeffs\fP points to the coefficient buffer\&. The array is of length numStages\&. 
.br
\fI*pState\fP points to the state buffer\&. The array is of length numStages\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_lattice_q15 (const \fBarm_fir_lattice_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR lattice structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_lattice_q31 (const \fBarm_fir_lattice_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR lattice structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_q15 (const \fBarm_fir_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_q31 (const \fBarm_fir_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 FIR filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_q7 (const \fBarm_fir_instance_q7\fP * S, \fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q7 FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q7 FIR filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_sparse_f32 (\fBarm_fir_sparse_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, \fBfloat32_t\fP * pScratchIn, uint32_t blockSize)"

.PP
Processing function for the floating-point sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point sparse FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fI*pScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_sparse_init_f32 (\fBarm_fir_sparse_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the floating-point sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the array of filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fI*pTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_sparse_init_q15 (\fBarm_fir_sparse_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the Q15 sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the array of filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fI*pTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_sparse_init_q31 (\fBarm_fir_sparse_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the Q31 sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the array of filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fI*pTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_sparse_init_q7 (\fBarm_fir_sparse_instance_q7\fP * S, uint16_t numTaps, \fBq7_t\fP * pCoeffs, \fBq7_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the Q7 sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q7 sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fI*pCoeffs\fP points to the array of filter coefficients\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fI*pTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_fir_sparse_q15 (\fBarm_fir_sparse_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratchIn, \fBq31_t\fP * pScratchOut, uint32_t blockSize)"

.PP
Processing function for the Q15 sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 sparse FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fI*pScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fI*pScratchOut\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_sparse_q31 (\fBarm_fir_sparse_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, \fBq31_t\fP * pScratchIn, uint32_t blockSize)"

.PP
Processing function for the Q31 sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 sparse FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fI*pScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_fir_sparse_q7 (\fBarm_fir_sparse_instance_q7\fP * S, \fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, \fBq7_t\fP * pScratchIn, \fBq31_t\fP * pScratchOut, uint32_t blockSize)"

.PP
Processing function for the Q7 sparse FIR filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q7 sparse FIR structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data 
.br
\fI*pScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fI*pScratchOut\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_float_to_q15 (\fBfloat32_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the floating-point vector to Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the floating-point input vector 
.br
\fI*pDst\fP points to the Q15 output vector 
.br
\fIblockSize\fP length of the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_float_to_q31 (\fBfloat32_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the floating-point vector to Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the floating-point input vector 
.br
\fI*pDst\fP points to the Q31 output vector 
.br
\fIblockSize\fP length of the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_float_to_q7 (\fBfloat32_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the floating-point vector to Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the floating-point input vector 
.br
\fI*pDst\fP points to the Q7 output vector 
.br
\fIblockSize\fP length of the input vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_iir_lattice_f32 (const \fBarm_iir_lattice_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point IIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point IIR lattice structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_iir_lattice_init_f32 (\fBarm_iir_lattice_instance_f32\fP * S, uint16_t numStages, \fBfloat32_t\fP * pkCoeffs, \fBfloat32_t\fP * pvCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point IIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point IIR lattice structure\&. 
.br
\fInumStages\fP number of stages in the filter\&. 
.br
\fI*pkCoeffs\fP points to the reflection coefficient buffer\&. The array is of length numStages\&. 
.br
\fI*pvCoeffs\fP points to the ladder coefficient buffer\&. The array is of length numStages+1\&. 
.br
\fI*pState\fP points to the state buffer\&. The array is of length numStages+blockSize-1\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_iir_lattice_init_q15 (\fBarm_iir_lattice_instance_q15\fP * S, uint16_t numStages, \fBq15_t\fP * pkCoeffs, \fBq15_t\fP * pvCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 IIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the fixed-point Q15 IIR lattice structure\&. 
.br
\fInumStages\fP number of stages in the filter\&. 
.br
\fI*pkCoeffs\fP points to reflection coefficient buffer\&. The array is of length numStages\&. 
.br
\fI*pvCoeffs\fP points to ladder coefficient buffer\&. The array is of length numStages+1\&. 
.br
\fI*pState\fP points to state buffer\&. The array is of length numStages+blockSize\&. 
.br
\fIblockSize\fP number of samples to process per call\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_iir_lattice_init_q31 (\fBarm_iir_lattice_instance_q31\fP * S, uint16_t numStages, \fBq31_t\fP * pkCoeffs, \fBq31_t\fP * pvCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 IIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 IIR lattice structure\&. 
.br
\fInumStages\fP number of stages in the filter\&. 
.br
\fI*pkCoeffs\fP points to the reflection coefficient buffer\&. The array is of length numStages\&. 
.br
\fI*pvCoeffs\fP points to the ladder coefficient buffer\&. The array is of length numStages+1\&. 
.br
\fI*pState\fP points to the state buffer\&. The array is of length numStages+blockSize\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_iir_lattice_q15 (const \fBarm_iir_lattice_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 IIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 IIR lattice structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_iir_lattice_q31 (const \fBarm_iir_lattice_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 IIR lattice filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 IIR lattice structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_f32 (const \fBarm_lms_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pRef, \fBfloat32_t\fP * pOut, \fBfloat32_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for floating-point LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point LMS filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pRef\fP points to the block of reference data\&. 
.br
\fI*pOut\fP points to the block of output data\&. 
.br
\fI*pErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_init_f32 (\fBarm_lms_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, \fBfloat32_t\fP mu, uint32_t blockSize)"

.PP
Initialization function for floating-point LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fI*pCoeffs\fP points to the coefficient buffer\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_init_q15 (\fBarm_lms_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, \fBq15_t\fP mu, uint32_t blockSize, uint32_t postShift)"

.PP
Initialization function for the Q15 LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fI*pCoeffs\fP points to the coefficient buffer\&. 
.br
\fI*pState\fP points to the state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_init_q31 (\fBarm_lms_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, \fBq31_t\fP mu, uint32_t blockSize, uint32_t postShift)"

.PP
Initialization function for Q31 LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fI*pCoeffs\fP points to coefficient buffer\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_norm_f32 (\fBarm_lms_norm_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pRef, \fBfloat32_t\fP * pOut, \fBfloat32_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for floating-point normalized LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point normalized LMS filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pRef\fP points to the block of reference data\&. 
.br
\fI*pOut\fP points to the block of output data\&. 
.br
\fI*pErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_norm_init_f32 (\fBarm_lms_norm_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, \fBfloat32_t\fP mu, uint32_t blockSize)"

.PP
Initialization function for floating-point normalized LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fI*pCoeffs\fP points to coefficient buffer\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_norm_init_q15 (\fBarm_lms_norm_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, \fBq15_t\fP mu, uint32_t blockSize, uint8_t postShift)"

.PP
Initialization function for Q15 normalized LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 normalized LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fI*pCoeffs\fP points to coefficient buffer\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_norm_init_q31 (\fBarm_lms_norm_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, \fBq31_t\fP mu, uint32_t blockSize, uint8_t postShift)"

.PP
Initialization function for Q31 normalized LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 normalized LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fI*pCoeffs\fP points to coefficient buffer\&. 
.br
\fI*pState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_norm_q15 (\fBarm_lms_norm_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pRef, \fBq15_t\fP * pOut, \fBq15_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q15 normalized LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 normalized LMS filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pRef\fP points to the block of reference data\&. 
.br
\fI*pOut\fP points to the block of output data\&. 
.br
\fI*pErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_norm_q31 (\fBarm_lms_norm_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pRef, \fBq31_t\fP * pOut, \fBq31_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q31 normalized LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 normalized LMS filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pRef\fP points to the block of reference data\&. 
.br
\fI*pOut\fP points to the block of output data\&. 
.br
\fI*pErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_q15 (const \fBarm_lms_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pRef, \fBq15_t\fP * pOut, \fBq15_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q15 LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 LMS filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pRef\fP points to the block of reference data\&. 
.br
\fI*pOut\fP points to the block of output data\&. 
.br
\fI*pErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_lms_q31 (const \fBarm_lms_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pRef, \fBq31_t\fP * pOut, \fBq31_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q31 LMS filter\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 LMS filter structure\&. 
.br
\fI*pSrc\fP points to the block of input data\&. 
.br
\fI*pRef\fP points to the block of reference data\&. 
.br
\fI*pOut\fP points to the block of output data\&. 
.br
\fI*pErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_add_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_add_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_add_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix addition\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "void arm_mat_init_f32 (\fBarm_matrix_instance_f32\fP * S, uint16_t nRows, uint16_t nColumns, \fBfloat32_t\fP * pData)"

.PP
Floating-point matrix initialization\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point matrix structure\&. 
.br
\fInRows\fP number of rows in the matrix\&. 
.br
\fInColumns\fP number of columns in the matrix\&. 
.br
\fI*pData\fP points to the matrix data array\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_mat_init_q15 (\fBarm_matrix_instance_q15\fP * S, uint16_t nRows, uint16_t nColumns, \fBq15_t\fP * pData)"

.PP
Q15 matrix initialization\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point matrix structure\&. 
.br
\fInRows\fP number of rows in the matrix\&. 
.br
\fInColumns\fP number of columns in the matrix\&. 
.br
\fI*pData\fP points to the matrix data array\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_mat_init_q31 (\fBarm_matrix_instance_q31\fP * S, uint16_t nRows, uint16_t nColumns, \fBq31_t\fP * pData)"

.PP
Q31 matrix initialization\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the floating-point matrix structure\&. 
.br
\fInRows\fP number of rows in the matrix\&. 
.br
\fInColumns\fP number of columns in the matrix\&. 
.br
\fI*pData\fP points to the matrix data array\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_inverse_f32 (const \fBarm_matrix_instance_f32\fP * src, \fBarm_matrix_instance_f32\fP * dst)"

.PP
Floating-point matrix inverse\&. end of PID group 
.PP
\fBParmetros:\fP
.RS 4
\fI*src\fP points to the instance of the input floating-point matrix structure\&. 
.br
\fI*dst\fP points to the instance of the output floating-point matrix structure\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match\&. If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_fast_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst, \fBq15_t\fP * pState)"

.PP
Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.br
\fI*pState\fP points to the array for storing intermediate results 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_fast_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst, \fBq15_t\fP * pState)"

.PP
Q15 matrix multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.br
\fI*pState\fP points to the array for storing intermediate results 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_scale_f32 (const \fBarm_matrix_instance_f32\fP * pSrc, \fBfloat32_t\fP scale, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix scaling\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input matrix 
.br
\fIscale\fP scale factor 
.br
\fI*pDst\fP points to the output matrix 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_scale_q15 (const \fBarm_matrix_instance_q15\fP * pSrc, \fBq15_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix scaling\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to input matrix 
.br
\fIscaleFract\fP fractional portion of the scale factor 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fI*pDst\fP points to output matrix 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_scale_q31 (const \fBarm_matrix_instance_q31\fP * pSrc, \fBq31_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix scaling\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to input matrix 
.br
\fIscaleFract\fP fractional portion of the scale factor 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_sub_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_sub_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_sub_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input matrix structure 
.br
\fI*pSrcB\fP points to the second input matrix structure 
.br
\fI*pDst\fP points to output matrix structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_trans_f32 (const \fBarm_matrix_instance_f32\fP * pSrc, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix transpose\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input matrix 
.br
\fI*pDst\fP points to the output matrix 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_trans_q15 (const \fBarm_matrix_instance_q15\fP * pSrc, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix transpose\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input matrix 
.br
\fI*pDst\fP points to the output matrix 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_trans_q31 (const \fBarm_matrix_instance_q31\fP * pSrc, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix transpose\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input matrix 
.br
\fI*pDst\fP points to the output matrix 
.RE
.PP
\fBDevuelve:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "void arm_max_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fI*pResult\fP maximum value returned here 
.br
\fI*pIndex\fP index of maximum value returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_max_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fI*pResult\fP maximum value returned here 
.br
\fI*pIndex\fP index of maximum value returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_max_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fI*pResult\fP maximum value returned here 
.br
\fI*pIndex\fP index of maximum value returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_max_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq7_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fI*pResult\fP maximum value returned here 
.br
\fI*pIndex\fP index of maximum value returned here 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mean_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Mean value of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mean_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Mean value of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mean_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Mean value of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mean_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq7_t\fP * pResult)"

.PP
Mean value of a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_min_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult, uint32_t * pIndex)"

.PP
Minimum value of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output pointer 
.br
\fI*pIndex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_min_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult, uint32_t * pIndex)"

.PP
Minimum value of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output pointer 
.br
\fI*pIndex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_min_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult, uint32_t * pIndex)"

.PP
Minimum value of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output pointer 
.br
\fI*pIndex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_min_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq7_t\fP * result, uint32_t * index)"

.PP
Minimum value of a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*result\fP is output pointer 
.br
\fIindex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mult_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mult_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mult_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_mult_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector multiplication\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_negate_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_negate_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_negate_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_negate_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_offset_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP offset, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_offset_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP offset, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_offset_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP offset, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_offset_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP offset, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_pid_init_f32 (\fBarm_pid_instance_f32\fP * S, int32_t resetStateFlag)"

.PP
Initialization function for the floating-point PID Control\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the PID structure\&. 
.br
\fIresetStateFlag\fP flag to reset the state\&. 0 = no change in state 1 = reset the state\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_pid_init_q15 (\fBarm_pid_instance_q15\fP * S, int32_t resetStateFlag)"

.PP
Initialization function for the Q15 PID Control\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 PID structure\&. 
.br
\fIresetStateFlag\fP flag to reset the state\&. 0 = no change in state 1 = reset the state\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_pid_init_q31 (\fBarm_pid_instance_q31\fP * S, int32_t resetStateFlag)"

.PP
Initialization function for the Q31 PID Control\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q15 PID structure\&. 
.br
\fIresetStateFlag\fP flag to reset the state\&. 0 = no change in state 1 = reset the state\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_pid_reset_f32 (\fBarm_pid_instance_f32\fP * S)"

.PP
Reset function for the floating-point PID Control\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP is an instance of the floating-point PID Control structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_pid_reset_q15 (\fBarm_pid_instance_q15\fP * S)"

.PP
Reset function for the Q15 PID Control\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the q15 PID Control structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_pid_reset_q31 (\fBarm_pid_instance_q31\fP * S)"

.PP
Reset function for the Q31 PID Control\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*S\fP points to an instance of the Q31 PID Control structure 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.SS "void arm_power_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Sum of the squares of the elements of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_power_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq63_t\fP * pResult)"

.PP
Sum of the squares of the elements of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_power_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq63_t\fP * pResult)"

.PP
Sum of the squares of the elements of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_power_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Sum of the squares of the elements of a Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q15_to_float (\fBq15_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q15 vector to floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q15_to_q31 (\fBq15_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q15 vector to Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q15_to_q7 (\fBq15_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q15 vector to Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q31_to_float (\fBq31_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q31 vector to floating-point vector\&. end of Inverse park group 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q31_to_q15 (\fBq31_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q31 vector to Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q31_to_q7 (\fBq31_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q31 vector to Q7 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q7_to_float (\fBq7_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q7 vector to floating-point vector\&. end of park group 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fI*pDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q7_to_q15 (\fBq7_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q7 vector to Q15 vector\&. end of inv_clarke group 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP input pointer 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_q7_to_q31 (\fBq7_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q7 vector to Q31 vector\&. end of clarke group 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP input pointer 
.br
\fI*pDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_rfft_f32 (const \fBarm_rfft_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst)"

.SS "void arm_rfft_fast_f32 (\fBarm_rfft_fast_instance_f32\fP * S, \fBfloat32_t\fP * p, \fBfloat32_t\fP * pOut, uint8_t ifftFlag)"

.SS "\fBarm_status\fP arm_rfft_fast_init_f32 (\fBarm_rfft_fast_instance_f32\fP * S, uint16_t fftLen)"

.SS "\fBarm_status\fP arm_rfft_init_f32 (\fBarm_rfft_instance_f32\fP * S, \fBarm_cfft_radix4_instance_f32\fP * S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_rfft_init_q15 (\fBarm_rfft_instance_q15\fP * S, \fBarm_cfft_radix4_instance_q15\fP * S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_rfft_init_q31 (\fBarm_rfft_instance_q31\fP * S, \fBarm_cfft_radix4_instance_q31\fP * S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"

.SS "void arm_rfft_q15 (const \fBarm_rfft_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst)"

.SS "void arm_rfft_q31 (const \fBarm_rfft_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst)"

.SS "void arm_rms_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Root Mean Square of the elements of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_rms_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Root Mean Square of the elements of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_rms_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Root Mean Square of the elements of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_scale_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP scale, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a floating-point vector by a scalar\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIscale\fP scale factor to be applied 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_scale_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP scaleFract, int8_t shift, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a Q15 vector by a scalar\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIscaleFract\fP fractional portion of the scale value 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_scale_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP scaleFract, int8_t shift, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a Q31 vector by a scalar\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIscaleFract\fP fractional portion of the scale value 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_scale_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP scaleFract, int8_t shift, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a Q7 vector by a scalar\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIscaleFract\fP fractional portion of the scale value 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_shift_q15 (\fBq15_t\fP * pSrc, int8_t shiftBits, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Shifts the elements of a Q15 vector a specified number of bits\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIshiftBits\fP number of bits to shift\&. A positive value shifts left; a negative value shifts right\&. 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_shift_q31 (\fBq31_t\fP * pSrc, int8_t shiftBits, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Shifts the elements of a Q31 vector a specified number of bits\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIshiftBits\fP number of bits to shift\&. A positive value shifts left; a negative value shifts right\&. 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_shift_q7 (\fBq7_t\fP * pSrc, int8_t shiftBits, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Shifts the elements of a Q7 vector a specified number of bits\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP points to the input vector 
.br
\fIshiftBits\fP number of bits to shift\&. A positive value shifts left; a negative value shifts right\&. 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_sin_cos_f32 (\fBfloat32_t\fP theta, \fBfloat32_t\fP * pSinVal, \fBfloat32_t\fP * pCcosVal)"

.SS "void arm_sin_cos_q31 (\fBq31_t\fP theta, \fBq31_t\fP * pSinVal, \fBq31_t\fP * pCosVal)"

.SS "\fBfloat32_t\fP arm_sin_f32 (\fBfloat32_t\fP x)"

.PP
Fast approximation to the trigonometric sine function for floating-point data\&. end of LinearInterpolate group 
.PP
\fBParmetros:\fP
.RS 4
\fIx\fP input value in radians\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
sin(x)\&. 
.RE
.PP

.SS "\fBq15_t\fP arm_sin_q15 (\fBq15_t\fP x)"

.PP
Fast approximation to the trigonometric sine function for Q15 data\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
sin(x)\&. 
.RE
.PP

.SS "\fBq31_t\fP arm_sin_q31 (\fBq31_t\fP x)"

.PP
Fast approximation to the trigonometric sine function for Q31 data\&. 
.PP
\fBParmetros:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
sin(x)\&. 
.RE
.PP

.SS "void arm_std_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Standard deviation of the elements of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_std_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Standard deviation of the elements of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_std_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Standard deviation of the elements of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_sub_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_sub_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_sub_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_sub_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector subtraction\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrcA\fP points to the first input vector 
.br
\fI*pSrcB\fP points to the second input vector 
.br
\fI*pDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_var_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Variance of the elements of a floating-point vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_var_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Variance of the elements of a Q15 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SS "void arm_var_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq63_t\fP * pResult)"

.PP
Variance of the elements of a Q31 vector\&. 
.PP
\fBParmetros:\fP
.RS 4
\fI*pSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fI*pResult\fP is output value\&. 
.RE
.PP
\fBDevuelve:\fP
.RS 4
none\&. 
.RE
.PP

.SH "Autor"
.PP 
Generado automticamente por Doxygen para Ejercicio 1 - TP 5 del cdigo fuente\&.
