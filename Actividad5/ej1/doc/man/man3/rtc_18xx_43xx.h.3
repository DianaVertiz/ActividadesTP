.TH "rtc_18xx_43xx.h" 3 "Viernes, 14 de Septiembre de 2018" "Ejercicio 1 - TP 5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
rtc_18xx_43xx.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Estructuras de datos"

.in +1c
.ti -1c
.RI "struct \fBLPC_RTC_T\fP"
.br
.RI "\fIReal Time Clock register block structure\&. \fP"
.ti -1c
.RI "struct \fBLPC_REGFILE_T\fP"
.br
.RI "\fIRegister File register block structure\&. \fP"
.ti -1c
.RI "struct \fBRTC_EV_TIMESTAMP_T\fP"
.br
.RI "\fIEvent Monitor/Recorder Timestamp structure\&. \fP"
.ti -1c
.RI "struct \fBRTC_TIME_T\fP"
.br
.in -1c
.SS "'defines'"

.in +1c
.ti -1c
.RI "#define \fBRTC_EV_SUPPORT\fP   1				/* Event Monitor/Recorder support */"
.br
.ti -1c
.RI "#define \fBRTC_ILR_BITMASK\fP   ((0x00000003))"
.br
.ti -1c
.RI "#define \fBRTC_IRL_RTCCIF\fP   ((1 << 0))"
.br
.ti -1c
.RI "#define \fBRTC_IRL_RTCALF\fP   ((1 << 1))"
.br
.ti -1c
.RI "#define \fBRTC_CCR_BITMASK\fP   ((0x00000013))"
.br
.ti -1c
.RI "#define \fBRTC_CCR_CLKEN\fP   ((1 << 0))"
.br
.ti -1c
.RI "#define \fBRTC_CCR_CTCRST\fP   ((1 << 1))"
.br
.ti -1c
.RI "#define \fBRTC_CCR_CCALEN\fP   ((1 << 4))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMSEC\fP   ((1 << 0))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMMIN\fP   ((1 << 1))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMHOUR\fP   ((1 << 2))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMDOM\fP   ((1 << 3))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMDOW\fP   ((1 << 4))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMDOY\fP   ((1 << 5))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMMON\fP   ((1 << 6))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_IMYEAR\fP   ((1 << 7))"
.br
.ti -1c
.RI "#define \fBRTC_AMR_CIIR_BITMASK\fP   ((0xFF))"
.br
.ti -1c
.RI "#define \fBRTC_AUX_RTC_OSCF\fP   ((1 << 4))"
.br
.ti -1c
.RI "#define \fBRTC_AUXEN_RTC_OSCFEN\fP   ((1 << 4))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME0_SECONDS_MASK\fP   ((0x3F))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME0_MINUTES_MASK\fP   ((0x3F00))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME0_HOURS_MASK\fP   ((0x1F0000))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME0_DOW_MASK\fP   ((0x7000000))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME1_DOM_MASK\fP   ((0x1F))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME1_MONTH_MASK\fP   ((0xF00))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME1_YEAR_MASK\fP   ((0xFFF0000))"
.br
.ti -1c
.RI "#define \fBRTC_CTIME2_DOY_MASK\fP   ((0xFFF))"
.br
.ti -1c
.RI "#define \fBRTC_SEC_MASK\fP   (0x0000003F)"
.br
.ti -1c
.RI "#define \fBRTC_MIN_MASK\fP   (0x0000003F)"
.br
.ti -1c
.RI "#define \fBRTC_HOUR_MASK\fP   (0x0000001F)"
.br
.ti -1c
.RI "#define \fBRTC_DOM_MASK\fP   (0x0000001F)"
.br
.ti -1c
.RI "#define \fBRTC_DOW_MASK\fP   (0x00000007)"
.br
.ti -1c
.RI "#define \fBRTC_DOY_MASK\fP   (0x000001FF)"
.br
.ti -1c
.RI "#define \fBRTC_MONTH_MASK\fP   (0x0000000F)"
.br
.ti -1c
.RI "#define \fBRTC_YEAR_MASK\fP   (0x00000FFF)"
.br
.ti -1c
.RI "#define \fBRTC_SECOND_MAX\fP   59"
.br
.ti -1c
.RI "#define \fBRTC_MINUTE_MAX\fP   59"
.br
.ti -1c
.RI "#define \fBRTC_HOUR_MAX\fP   23"
.br
.ti -1c
.RI "#define \fBRTC_MONTH_MIN\fP   1"
.br
.ti -1c
.RI "#define \fBRTC_MONTH_MAX\fP   12"
.br
.ti -1c
.RI "#define \fBRTC_DAYOFMONTH_MIN\fP   1"
.br
.ti -1c
.RI "#define \fBRTC_DAYOFMONTH_MAX\fP   31"
.br
.ti -1c
.RI "#define \fBRTC_DAYOFWEEK_MAX\fP   6"
.br
.ti -1c
.RI "#define \fBRTC_DAYOFYEAR_MIN\fP   1"
.br
.ti -1c
.RI "#define \fBRTC_DAYOFYEAR_MAX\fP   366"
.br
.ti -1c
.RI "#define \fBRTC_YEAR_MAX\fP   4095"
.br
.ti -1c
.RI "#define \fBRTC_CALIBRATION_CALVAL_MASK\fP   ((0x1FFFF))"
.br
.ti -1c
.RI "#define \fBRTC_CALIBRATION_LIBDIR\fP   ((1 << 17))"
.br
.ti -1c
.RI "#define \fBRTC_CALIBRATION_MAX\fP   ((0x20000))"
.br
.ti -1c
.RI "#define \fBRTC_CALIB_DIR_FORWARD\fP   ((uint8_t) (0))"
.br
.ti -1c
.RI "#define \fBRTC_CALIB_DIR_BACKWARD\fP   ((uint8_t) (1))"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_BITMASK\fP   ((uint32_t) 0xC0F03C0F)"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_INTWAKE_EN\fP   ((uint32_t) (1 << 0))"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_GPCLEAR_EN\fP   ((uint32_t) (1 << 1))"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_POL_NEGATIVE\fP   (0)		/* Event as positive edge */"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_POL_POSITIVE\fP   ((uint32_t) (1 << 2))	/* Event as negative edge */"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_INPUT_EN\fP   ((uint32_t) (1 << 3))"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_CHANNEL_CONFIG_BITMASK\fP(ch)   ((uint32_t) (0x0F << (10 * ch)))"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_CHANNEL_CONFIG\fP(ch,  \fBflag\fP)   ((uint32_t) (\fBflag\fP << (10 * ch)))"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_MODE_MASK\fP   (((uint32_t) 3) << 30)"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_MODE_CLK_DISABLE\fP   (((uint32_t) 0) << 30)"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_MODE_16HZ\fP   (((uint32_t) 1) << 30)"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_MODE_64HZ\fP   (((uint32_t) 2) << 30)"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_MODE_1KHZ\fP   (((uint32_t) 3) << 30)"
.br
.ti -1c
.RI "#define \fBRTC_ERCTRL_MODE\fP(n)   (((uint32_t) n) << 30)"
.br
.ti -1c
.RI "#define \fBRTC_ERSTATUS_CHANNEL_EV\fP(ch)   ((uint32_t) (1 << ch))		/* At least 1 event has occurred on a specific channel */"
.br
.ti -1c
.RI "#define \fBRTC_ERSTATUS_GPCLEARED\fP   ((uint32_t) (1 << 3))"
.br
.ti -1c
.RI "#define \fBRTC_ERSTATUS_WAKEUP\fP   ((uint32_t) (((uint32_t) 1) << 31))"
.br
.ti -1c
.RI "#define \fBRTC_ER_COUNTER\fP(ch,  n)   ((uint32_t) ((n >> (8 * ch)) & 0x07))"
.br
.ti -1c
.RI "#define \fBRTC_ER_TIMESTAMP_SEC\fP(n)   ((uint32_t) (n & 0x3F))"
.br
.ti -1c
.RI "#define \fBRTC_ER_TIMESTAMP_MIN\fP(n)   ((uint32_t) ((n >> 6) & 0x3F))"
.br
.ti -1c
.RI "#define \fBRTC_ER_TIMESTAMP_HOUR\fP(n)   ((uint32_t) ((n >> 12) & 0x1F))"
.br
.ti -1c
.RI "#define \fBRTC_ER_TIMESTAMP_DOY\fP(n)   ((uint32_t) ((n >> 17) & 0x1FF))"
.br
.in -1c
.SS "'typedefs'"

.in +1c
.ti -1c
.RI "typedef enum \fBIP_RTC_EV_MODE\fP \fBRTC_EV_MODE_T\fP"
.br
.RI "\fIEvent Monitor/Recorder Mode definition\&. \fP"
.in -1c
.SS "Enumeraciones"

.in +1c
.ti -1c
.RI "enum \fBRTC_TIMEINDEX_T\fP { \fBRTC_TIMETYPE_SECOND\fP, \fBRTC_TIMETYPE_MINUTE\fP, \fBRTC_TIMETYPE_HOUR\fP, \fBRTC_TIMETYPE_DAYOFMONTH\fP, \fBRTC_TIMETYPE_DAYOFWEEK\fP, \fBRTC_TIMETYPE_DAYOFYEAR\fP, \fBRTC_TIMETYPE_MONTH\fP, \fBRTC_TIMETYPE_YEAR\fP, \fBRTC_TIMETYPE_LAST\fP }
.RI "\fIRTC time type option\&. \fP""
.br
.ti -1c
.RI "enum \fBRTC_EV_CHANNEL_T\fP { \fBRTC_EV_CHANNEL_1\fP = 0, \fBRTC_EV_CHANNEL_2\fP, \fBRTC_EV_CHANNEL_3\fP, \fBRTC_EV_CHANNEL_NUM\fP }
.RI "\fIEvent Channel Identifier definitions\&. \fP""
.br
.ti -1c
.RI "enum \fBIP_RTC_EV_MODE\fP { \fBRTC_EV_MODE_DISABLE\fP = 0, \fBRTC_EV_MODE_ENABLE_16HZ\fP = 1, \fBRTC_EV_MODE_ENABLE_64HZ\fP = 2, \fBRTC_EV_MODE_ENABLE_1KHZ\fP = 3, \fBRTC_EV_MODE_LAST\fP }
.RI "\fIEvent Monitor/Recorder Mode definition\&. \fP""
.br
.ti -1c
.RI "enum \fBRTC_INT_OPT_T\fP { \fBRTC_INT_COUNTER_INCREASE\fP = RTC_IRL_RTCCIF, \fBRTC_INT_ALARM\fP = RTC_IRL_RTCALF }
.RI "\fIRTC enumeration\&. \fP""
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "void \fBChip_RTC_ResetClockTickCounter\fP (\fBLPC_RTC_T\fP *pRTC)"
.br
.RI "\fIReset clock tick counter in the RTC peripheral\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_Enable\fP (\fBLPC_RTC_T\fP *pRTC, \fBFunctionalState\fP NewState)"
.br
.RI "\fIStart/Stop RTC peripheral\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_CntIncrIntConfig\fP (\fBLPC_RTC_T\fP *pRTC, uint32_t cntrMask, \fBFunctionalState\fP NewState)"
.br
.RI "\fIEnable/Disable Counter increment interrupt for a time type in the RTC peripheral\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_AlarmIntConfig\fP (\fBLPC_RTC_T\fP *pRTC, uint32_t alarmMask, \fBFunctionalState\fP NewState)"
.br
.RI "\fIEnable/Disable Alarm interrupt for a time type in the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_SetTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIMEINDEX_T\fP Timetype, uint32_t TimeValue)"
.br
.RI "\fISet current time value for a time type in the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_RTC_GetTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIMEINDEX_T\fP Timetype)"
.br
.RI "\fIGet current time value for a type time type\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_SetFullTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIME_T\fP *pFullTime)"
.br
.RI "\fISet full time in the RTC peripheral\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_GetFullTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIME_T\fP *pFullTime)"
.br
.RI "\fIGet full time from the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_SetAlarmTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIMEINDEX_T\fP Timetype, uint32_t ALValue)"
.br
.RI "\fISet alarm time value for a time type\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_RTC_GetAlarmTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIMEINDEX_T\fP Timetype)"
.br
.RI "\fIGet alarm time value for a time type\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_SetFullAlarmTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIME_T\fP *pFullTime)"
.br
.RI "\fISet full alarm time in the RTC peripheral\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_GetFullAlarmTime\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_TIME_T\fP *pFullTime)"
.br
.RI "\fIGet full alarm time in the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_REGFILE_Write\fP (\fBLPC_REGFILE_T\fP *pRegFile, uint8_t index, uint32_t value)"
.br
.RI "\fIWrite value to General purpose registers\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint32_t \fBChip_REGFILE_Read\fP (\fBLPC_REGFILE_T\fP *pRegFile, uint8_t index)"
.br
.RI "\fIRead value from General purpose registers\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_CalibCounterCmd\fP (\fBLPC_RTC_T\fP *pRTC, \fBFunctionalState\fP NewState)"
.br
.RI "\fIEnable/Disable calibration counter in the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_CalibConfig\fP (\fBLPC_RTC_T\fP *pRTC, uint32_t CalibValue, uint8_t CalibDir)"
.br
.RI "\fIConfigures Calibration in the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_ClearIntPending\fP (\fBLPC_RTC_T\fP *pRTC, uint32_t IntType)"
.br
.RI "\fIClear specified Location interrupt pending in the RTC peripheral\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP \fBIntStatus\fP \fBChip_RTC_GetIntPending\fP (\fBLPC_RTC_T\fP *pRTC, uint32_t IntType)"
.br
.RI "\fICheck whether if specified location interrupt in the RTC peripheral is set or not\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_EV_Config\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_CHANNEL_T\fP ch, uint32_t \fBflag\fP)"
.br
.RI "\fIConfigure a specific event channel\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_EV_SetMode\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_MODE_T\fP mode)"
.br
.RI "\fIEnable/Disable and select clock frequency for Event Monitor/Recorder\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint8_t \fBChip_RTC_EV_GetStatus\fP (\fBLPC_RTC_T\fP *pRTC)"
.br
.RI "\fIGet Event Monitor/Recorder Status\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_EV_ClearStatus\fP (\fBLPC_RTC_T\fP *pRTC, uint32_t \fBflag\fP)"
.br
.RI "\fIClear Event Monitor/Recorder Status\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP \fBFlagStatus\fP \fBChip_RTC_EV_GetChannelStatus\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_CHANNEL_T\fP ch)"
.br
.RI "\fIGet status of a specific event channel\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP void \fBChip_RTC_EV_ClearChannelStatus\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_CHANNEL_T\fP ch)"
.br
.RI "\fIClear status of a specific event channel\&. \fP"
.ti -1c
.RI "\fBSTATIC\fP \fBINLINE\fP uint8_t \fBChip_RTC_EV_GetCounter\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_CHANNEL_T\fP ch)"
.br
.RI "\fIGet counter value of a specific event channel\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_EV_GetFirstTimeStamp\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_CHANNEL_T\fP ch, \fBRTC_EV_TIMESTAMP_T\fP *pTimeStamp)"
.br
.RI "\fIGet first time stamp of a specific event channel\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_EV_GetLastTimeStamp\fP (\fBLPC_RTC_T\fP *pRTC, \fBRTC_EV_CHANNEL_T\fP ch, \fBRTC_EV_TIMESTAMP_T\fP *pTimeStamp)"
.br
.RI "\fIGet last time stamp of a specific event channel\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_Init\fP (\fBLPC_RTC_T\fP *pRTC)"
.br
.RI "\fIInitialize the RTC peripheral\&. \fP"
.ti -1c
.RI "void \fBChip_RTC_DeInit\fP (\fBLPC_RTC_T\fP *pRTC)"
.br
.RI "\fIDe-initialize the RTC peripheral\&. \fP"
.in -1c
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para Ejercicio 1 - TP 5 del código fuente\&.
