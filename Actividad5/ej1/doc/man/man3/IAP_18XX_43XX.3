.TH "IAP_18XX_43XX" 3 "Viernes, 14 de Septiembre de 2018" "Ejercicio 1 - TP 5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IAP_18XX_43XX \- CHIP: LPC18xx/43xx Flash IAP driver
.SS "'defines'"

.in +1c
.ti -1c
.RI "#define \fBIAP_PREWRRITE_CMD\fP   50"
.br
.ti -1c
.RI "#define \fBIAP_WRISECTOR_CMD\fP   51"
.br
.ti -1c
.RI "#define \fBIAP_ERSSECTOR_CMD\fP   52"
.br
.ti -1c
.RI "#define \fBIAP_BLANK_CHECK_SECTOR_CMD\fP   53"
.br
.ti -1c
.RI "#define \fBIAP_REPID_CMD\fP   54"
.br
.ti -1c
.RI "#define \fBIAP_READ_BOOT_CODE_CMD\fP   55"
.br
.ti -1c
.RI "#define \fBIAP_COMPARE_CMD\fP   56"
.br
.ti -1c
.RI "#define \fBIAP_REINVOKE_ISP_CMD\fP   57"
.br
.ti -1c
.RI "#define \fBIAP_READ_UID_CMD\fP   58"
.br
.ti -1c
.RI "#define \fBIAP_ERASE_PAGE_CMD\fP   59"
.br
.ti -1c
.RI "#define \fBIAP_SET_BOOT_FLASH\fP   60"
.br
.ti -1c
.RI "#define \fBIAP_EEPROM_WRITE\fP   61"
.br
.ti -1c
.RI "#define \fBIAP_EEPROM_READ\fP   62"
.br
.ti -1c
.RI "#define \fBIAP_CMD_SUCCESS\fP   0"
.br
.ti -1c
.RI "#define \fBIAP_INVALID_COMMAND\fP   1"
.br
.ti -1c
.RI "#define \fBIAP_SRC_ADDR_ERROR\fP   2"
.br
.ti -1c
.RI "#define \fBIAP_DST_ADDR_ERROR\fP   3"
.br
.ti -1c
.RI "#define \fBIAP_SRC_ADDR_NOT_MAPPED\fP   4"
.br
.ti -1c
.RI "#define \fBIAP_DST_ADDR_NOT_MAPPED\fP   5"
.br
.ti -1c
.RI "#define \fBIAP_COUNT_ERROR\fP   6"
.br
.ti -1c
.RI "#define \fBIAP_INVALID_SECTOR\fP   7"
.br
.ti -1c
.RI "#define \fBIAP_SECTOR_NOT_BLANK\fP   8"
.br
.ti -1c
.RI "#define \fBIAP_SECTOR_NOT_PREPARED\fP   9"
.br
.ti -1c
.RI "#define \fBIAP_COMPARE_ERROR\fP   10"
.br
.ti -1c
.RI "#define \fBIAP_BUSY\fP   11"
.br
.ti -1c
.RI "#define \fBIAP_PARAM_ERROR\fP   12"
.br
.ti -1c
.RI "#define \fBIAP_ADDR_ERROR\fP   13"
.br
.ti -1c
.RI "#define \fBIAP_ADDR_NOT_MAPPED\fP   14"
.br
.ti -1c
.RI "#define \fBIAP_CMD_LOCKED\fP   15"
.br
.ti -1c
.RI "#define \fBIAP_INVALID_CODE\fP   16"
.br
.ti -1c
.RI "#define \fBIAP_INVALID_BAUD_RATE\fP   17"
.br
.ti -1c
.RI "#define \fBIAP_INVALID_STOP_BIT\fP   18"
.br
.ti -1c
.RI "#define \fBIAP_CRP_ENABLED\fP   19"
.br
.in -1c
.SS "'typedefs'"

.in +1c
.ti -1c
.RI "typedef void(* \fBIAP_ENTRY_T\fP) (unsigned int[5], unsigned int[4])"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "uint8_t \fBChip_IAP_Init\fP (void)"
.br
.RI "\fIInitialize IAP\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_PreSectorForReadWrite\fP (uint32_t strSector, uint32_t endSector, uint8_t bankNum)"
.br
.RI "\fIPrepare sector for write operation\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_CopyRamToFlash\fP (uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt)"
.br
.RI "\fICopy RAM to flash\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_EraseSector\fP (uint32_t strSector, uint32_t endSector, uint8_t bankNum)"
.br
.RI "\fIErase sector\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_BlankCheckSector\fP (uint32_t strSector, uint32_t endSector, uint8_t bankNum)"
.br
.RI "\fIBlank check a sector or multiples sector of on-chip flash memory\&. \fP"
.ti -1c
.RI "uint32_t \fBChip_IAP_ReadPID\fP (void)"
.br
.RI "\fIRead part identification number\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_ReadBootCode\fP (void)"
.br
.RI "\fIRead boot code version number\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_Compare\fP (uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp)"
.br
.RI "\fICompare the memory contents at two locations\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_ReinvokeISP\fP (void)"
.br
.RI "\fIIAP reinvoke ISP to invoke the bootloader in ISP mode\&. \fP"
.ti -1c
.RI "uint32_t \fBChip_IAP_ReadUID\fP (uint32_t uid[])"
.br
.RI "\fIRead the unique ID\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_ErasePage\fP (uint32_t strPage, uint32_t endPage)"
.br
.RI "\fIErase a page or multiple papers of on-chip flash memory\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_SetBootFlashBank\fP (uint8_t bankNum)"
.br
.RI "\fISet active boot flash bank\&. \fP"
.ti -1c
.RI "uint8_t \fBChip_IAP_init\fP (void)"
.br
.RI "\fIInitialize the IAP command interface\&. \fP"
.in -1c
.SH "Descripción detallada"
.PP 

.SH "Documentación de los 'defines'"
.PP 
.SS "#define IAP_ADDR_ERROR   13"
Address is not on word boundary 
.PP
Definición en la línea 73 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_ADDR_NOT_MAPPED   14"
Address is not mapped in the memory map 
.PP
Definición en la línea 74 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_BLANK_CHECK_SECTOR_CMD   53"
Blank check sector 
.PP
Definición en la línea 48 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_BUSY   11"
Flash programming hardware interface is busy 
.PP
Definición en la línea 71 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_CMD_LOCKED   15"
Command is locked 
.PP
Definición en la línea 75 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_CMD_SUCCESS   0"
Command is executed successfully 
.PP
Definición en la línea 60 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_COMPARE_CMD   56"
Compare two RAM address locations 
.PP
Definición en la línea 51 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_COMPARE_ERROR   10"
Source and destination data not equal 
.PP
Definición en la línea 70 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_COUNT_ERROR   6"
Byte count is not multiple of 4 or is not a permitted value 
.PP
Definición en la línea 66 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_CRP_ENABLED   19"
Code read protection enabled 
.PP
Definición en la línea 79 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_DST_ADDR_ERROR   3"
Destination address is not on a correct boundary 
.PP
Definición en la línea 63 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_DST_ADDR_NOT_MAPPED   5"
Destination address is not mapped in the memory map 
.PP
Definición en la línea 65 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_EEPROM_READ   62"
EEPROM READ command 
.PP
Definición en la línea 57 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_EEPROM_WRITE   61"
EEPROM Write command 
.PP
Definición en la línea 56 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_ERASE_PAGE_CMD   59"
Erase page 
.PP
Definición en la línea 54 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_ERSSECTOR_CMD   52"
Erase Sector command 
.PP
Definición en la línea 47 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_INVALID_BAUD_RATE   17"
Invalid baud rate setting 
.PP
Definición en la línea 77 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_INVALID_CODE   16"
Unlock code is invalid 
.PP
Definición en la línea 76 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_INVALID_COMMAND   1"
Invalid command 
.PP
Definición en la línea 61 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_INVALID_SECTOR   7"
Sector number is invalid or end sector number is greater than start sector number 
.PP
Definición en la línea 67 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_INVALID_STOP_BIT   18"
Invalid stop bit setting 
.PP
Definición en la línea 78 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_PARAM_ERROR   12"
nsufficient number of parameters or invalid parameter 
.PP
Definición en la línea 72 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_PREWRRITE_CMD   50"
Prepare sector for write operation command 
.PP
Definición en la línea 45 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_READ_BOOT_CODE_CMD   55"
Read Boot code version 
.PP
Definición en la línea 50 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_READ_UID_CMD   58"
Read UID 
.PP
Definición en la línea 53 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_REINVOKE_ISP_CMD   57"
Reinvoke ISP 
.PP
Definición en la línea 52 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_REPID_CMD   54"
Read PartID command 
.PP
Definición en la línea 49 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_SECTOR_NOT_BLANK   8"
Sector is not blank 
.PP
Definición en la línea 68 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_SECTOR_NOT_PREPARED   9"
Command to prepare sector for write operation was not executed 
.PP
Definición en la línea 69 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_SET_BOOT_FLASH   60"
Set active boot flash bank 
.PP
Definición en la línea 55 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_SRC_ADDR_ERROR   2"
Source address is not on word boundary 
.PP
Definición en la línea 62 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_SRC_ADDR_NOT_MAPPED   4"
Source address is not mapped in the memory map 
.PP
Definición en la línea 64 del archivo iap_18xx_43xx\&.h\&.
.SS "#define IAP_WRISECTOR_CMD   51"
Write Sector command 
.PP
Definición en la línea 46 del archivo iap_18xx_43xx\&.h\&.
.SH "Documentación de los 'typedefs'"
.PP 
.SS "typedef void(* IAP_ENTRY_T) (unsigned int[5], unsigned int[4])"

.PP
Definición en la línea 82 del archivo iap_18xx_43xx\&.h\&.
.SH "Documentación de las funciones"
.PP 
.SS "uint8_t Chip_IAP_BlankCheckSector (uint32_t strSector, uint32_t endSector, uint8_t bankNum)"

.PP
Blank check a sector or multiples sector of on-chip flash memory\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIstrSector\fP : Start sector number 
.br
\fIendSector\fP : End sector number 
.br
\fIbankNum\fP : Flash Bank number 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK 
.RE
.PP
\fBNota:\fP
.RS 4
The end sector must be greater than or equal to start sector number 
.RE
.PP

.PP
Definición en la línea 106 del archivo iap_18xx_43xx\&.c\&.
.SS "uint8_t Chip_IAP_Compare (uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp)"

.PP
Compare the memory contents at two locations\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIdstAdd\fP : Destination of the RAM address of data bytes to be compared 
.br
\fIsrcAdd\fP : Source of the RAM address of data bytes to be compared 
.br
\fIbytescmp\fP : Number of bytes to be compared 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Offset of the first mismatch of the status code is COMPARE_ERROR 
.RE
.PP
\fBNota:\fP
.RS 4
The addresses should be a word boundary and number of bytes should be a multiply of 4 
.RE
.PP

.PP
Definición en la línea 128 del archivo iap\&.c\&.
.SS "uint8_t Chip_IAP_CopyRamToFlash (uint32_t dstAdd, uint32_t * srcAdd, uint32_t byteswrt)"

.PP
Copy RAM to flash\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIdstAdd\fP : Destination flash address where data bytes are to be written 
.br
\fIsrcAdd\fP : Source flash address where data bytes are to be read 
.br
\fIbyteswrt\fP : Number of bytes to be written 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP
\fBNota:\fP
.RS 4
The addresses should be a 256 byte boundary and the number of bytes should be 256 | 512 | 1024 | 4096
.RE
.PP
\fBParámetros:\fP
.RS 4
\fIdstAdd\fP : Destination FLASH address where data bytes are to be written 
.br
\fIsrcAdd\fP : Source RAM address where data bytes are to be read 
.br
\fIbyteswrt\fP : Number of bytes to be written 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP
\fBNota:\fP
.RS 4
The addresses should be a 256 byte boundary and the number of bytes should be 256 | 512 | 1024 | 4096 
.RE
.PP

.PP
Definición en la línea 64 del archivo iap\&.c\&.
.SS "uint8_t Chip_IAP_ErasePage (uint32_t strPage, uint32_t endPage)"

.PP
Erase a page or multiple papers of on-chip flash memory\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIstrPage\fP : Start page number 
.br
\fIendPage\fP : End page number 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP
\fBNota:\fP
.RS 4
The page number must be greater than or equal to start page number 
.RE
.PP

.PP
Definición en la línea 168 del archivo iap\&.c\&.
.SS "uint8_t Chip_IAP_EraseSector (uint32_t strSector, uint32_t endSector, uint8_t bankNum)"

.PP
Erase sector\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIstrSector\fP : Start sector number 
.br
\fIendSector\fP : End sector number 
.br
\fIbankNum\fP : Flash Bank number 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP
\fBNota:\fP
.RS 4
The end sector must be greater than or equal to start sector number 
.RE
.PP

.PP
Definición en la línea 91 del archivo iap_18xx_43xx\&.c\&.
.SS "uint8_t Chip_IAP_Init (void)"

.PP
Initialize IAP\&. 
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP

.PP
Definición en la línea 51 del archivo iap_18xx_43xx\&.c\&.
.SS "uint8_t Chip_IAP_init (void)"

.PP
Initialize the IAP command interface\&. 
.PP
\fBDevuelve:\fP
.RS 4
IAP_CMD_SUCCESS on success 
.RE
.PP
\fBNota:\fP
.RS 4
On parts with flash this API must be called before using IAP interface 
.RE
.PP

.SS "uint8_t Chip_IAP_PreSectorForReadWrite (uint32_t strSector, uint32_t endSector, uint8_t bankNum)"

.PP
Prepare sector for write operation\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIstrSector\fP : Start sector number 
.br
\fIendSector\fP : End sector number 
.br
\fIbankNum\fP : Flash Bank number 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP
\fBNota:\fP
.RS 4
This command must be executed before executing 'Copy RAM to flash' or 'Erase Sector' command\&. The end sector must be greater than or equal to start sector number 
.RE
.PP

.PP
Definición en la línea 62 del archivo iap_18xx_43xx\&.c\&.
.SS "uint8_t Chip_IAP_ReadBootCode (void)"

.PP
Read boot code version number\&. 
.PP
\fBDevuelve:\fP
.RS 4
Boot code version number 
.RE
.PP

.PP
Definición en la línea 117 del archivo iap\&.c\&.
.SS "uint32_t Chip_IAP_ReadPID (void)"

.PP
Read part identification number\&. 
.PP
\fBDevuelve:\fP
.RS 4
Part identification number 
.RE
.PP

.PP
Definición en la línea 106 del archivo iap\&.c\&.
.SS "uint32_t Chip_IAP_ReadUID (uint32_t uid[])"

.PP
Read the unique ID\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIuid[]\fP : Array of uint32_t with 4 elements to return the UID 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP

.PP
Definición en la línea 167 del archivo iap_18xx_43xx\&.c\&.
.SS "uint8_t Chip_IAP_ReinvokeISP (void)"

.PP
IAP reinvoke ISP to invoke the bootloader in ISP mode\&. 
.PP
\fBDevuelve:\fP
.RS 4
none 
.RE
.PP

.PP
Definición en la línea 142 del archivo iap\&.c\&.
.SS "uint8_t Chip_IAP_SetBootFlashBank (uint8_t bankNum)"

.PP
Set active boot flash bank\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIbankNum\fP : Flash bank number 
.RE
.PP
\fBDevuelve:\fP
.RS 4
Status code to indicate the command is executed successfully or not 
.RE
.PP
\fBNota:\fP
.RS 4
Enable booting from the indicated flash unit by inserting a valid signature and invalidating the other flash unit 
.RE
.PP

.PP
Definición en la línea 195 del archivo iap_18xx_43xx\&.c\&.
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para Ejercicio 1 - TP 5 del código fuente\&.
