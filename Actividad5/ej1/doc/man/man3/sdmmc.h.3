.TH "sdmmc.h" 3 "Viernes, 14 de Septiembre de 2018" "Ejercicio 1 - TP 5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
sdmmc.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Estructuras de datos"

.in +1c
.ti -1c
.RI "struct \fBSDMMC_CARD_T\fP"
.br
.RI "\fISD/MMC Card specific setup data structure\&. \fP"
.in -1c
.SS "'defines'"

.in +1c
.ti -1c
.RI "#define \fBSDC_OCR_20_21\fP   (((uint32_t) 1) << 8)"
.br
.RI "\fIOCR Register definitions\&. \fP"
.ti -1c
.RI "#define \fBSDC_OCR_21_22\fP   (((uint32_t) 1) << 9)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_22_23\fP   (((uint32_t) 1) << 10)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_23_24\fP   (((uint32_t) 1) << 11)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_24_25\fP   (((uint32_t) 1) << 12)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_25_26\fP   (((uint32_t) 1) << 13)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_26_27\fP   (((uint32_t) 1) << 14)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_27_28\fP   (((uint32_t) 1) << 15)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_28_29\fP   (((uint32_t) 1) << 16)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_29_30\fP   (((uint32_t) 1) << 17)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_30_31\fP   (((uint32_t) 1) << 18)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_31_32\fP   (((uint32_t) 1) << 19)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_32_33\fP   (((uint32_t) 1) << 20)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_33_34\fP   (((uint32_t) 1) << 21)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_34_35\fP   (((uint32_t) 1) << 22)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_35_36\fP   (((uint32_t) 1) << 23)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_27_36\fP   ((uint32_t) 0x00FF8000)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_HC_CCS\fP   (((uint32_t) 1) << 30)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_IDLE\fP   (((uint32_t) 1) << 31)"
.br
.ti -1c
.RI "#define \fBSDC_OCR_BUSY\fP   (((uint32_t) 0) << 31)"
.br
.ti -1c
.RI "#define \fBMMC_GO_IDLE_STATE\fP   0		/* bc                          */"
.br
.RI "\fISD/MMC commands, arguments and responses Standard SD/MMC commands (3\&.1) type argument response\&. \fP"
.ti -1c
.RI "#define \fBMMC_SEND_OP_COND\fP   1		/* bcr  [31:0]  OCR        R3  */"
.br
.ti -1c
.RI "#define \fBMMC_ALL_SEND_CID\fP   2		/* bcr                     R2  */"
.br
.ti -1c
.RI "#define \fBMMC_SET_RELATIVE_ADDR\fP   3		/* ac   [31:16] RCA        R1  */"
.br
.ti -1c
.RI "#define \fBMMC_SET_DSR\fP   4		/* bc   [31:16] RCA            */"
.br
.ti -1c
.RI "#define \fBMMC_SELECT_CARD\fP   7		/* ac   [31:16] RCA        R1  */"
.br
.ti -1c
.RI "#define \fBMMC_SEND_EXT_CSD\fP   8		/* bc                      R1  */"
.br
.ti -1c
.RI "#define \fBMMC_SEND_CSD\fP   9		/* ac   [31:16] RCA        R2  */"
.br
.ti -1c
.RI "#define \fBMMC_SEND_CID\fP   10		/* ac   [31:16] RCA        R2  */"
.br
.ti -1c
.RI "#define \fBMMC_STOP_TRANSMISSION\fP   12		/* ac                      R1b */"
.br
.ti -1c
.RI "#define \fBMMC_SEND_STATUS\fP   13		/* ac   [31:16] RCA        R1  */"
.br
.ti -1c
.RI "#define \fBMMC_GO_INACTIVE_STATE\fP   15		/* ac   [31:16] RCA            */"
.br
.ti -1c
.RI "#define \fBMMC_SET_BLOCKLEN\fP   16		/* ac   [31:0]  block len  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_READ_SINGLE_BLOCK\fP   17		/* adtc [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_READ_MULTIPLE_BLOCK\fP   18		/* adtc [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_WRITE_DAT_UNTIL_STOP\fP   20		/* adtc [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_SET_BLOCK_COUNT\fP   23		/* adtc [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_WRITE_BLOCK\fP   24		/* adtc [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_WRITE_MULTIPLE_BLOCK\fP   25		/* adtc                    R1  */"
.br
.ti -1c
.RI "#define \fBMMC_PROGRAM_CID\fP   26		/* adtc                    R1  */"
.br
.ti -1c
.RI "#define \fBMMC_PROGRAM_CSD\fP   27		/* adtc                    R1  */"
.br
.ti -1c
.RI "#define \fBMMC_SET_WRITE_PROT\fP   28		/* ac   [31:0]  data addr  R1b */"
.br
.ti -1c
.RI "#define \fBMMC_CLR_WRITE_PROT\fP   29		/* ac   [31:0]  data addr  R1b */"
.br
.ti -1c
.RI "#define \fBMMC_SEND_WRITE_PROT\fP   30		/* adtc [31:0]  wpdata addr R1  */"
.br
.ti -1c
.RI "#define \fBMMC_ERASE_GROUP_START\fP   35		/* ac   [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_ERASE_GROUP_END\fP   36		/* ac   [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBMMC_ERASE\fP   37		/* ac                      R1b */"
.br
.ti -1c
.RI "#define \fBSD_ERASE_WR_BLK_START\fP   32		/* ac   [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBSD_ERASE_WR_BLK_END\fP   33		/* ac   [31:0]  data addr  R1  */"
.br
.ti -1c
.RI "#define \fBSD_ERASE\fP   38		/* ac                      R1b */"
.br
.ti -1c
.RI "#define \fBMMC_FAST_IO\fP   39		/* ac   <Complex>          R4  */"
.br
.ti -1c
.RI "#define \fBMMC_GO_IRQ_STATE\fP   40		/* bcr                     R5  */"
.br
.ti -1c
.RI "#define \fBMMC_LOCK_UNLOCK\fP   42		/* adtc                    R1b */"
.br
.ti -1c
.RI "#define \fBMMC_APP_CMD\fP   55		/* ac   [31:16] RCA        R1  */"
.br
.ti -1c
.RI "#define \fBMMC_GEN_CMD\fP   56		/* adtc [0]     RD/WR      R1b */"
.br
.ti -1c
.RI "#define \fBSD_SEND_RELATIVE_ADDR\fP   3		/* ac                      R6  */"
.br
.ti -1c
.RI "#define \fBSD_CMD8\fP   8		/* bcr  [31:0]  OCR        R3  */"
.br
.ti -1c
.RI "#define \fBSD_APP_SET_BUS_WIDTH\fP   6		/* ac   [1:0]   bus width  R1   */"
.br
.ti -1c
.RI "#define \fBSD_APP_OP_COND\fP   41		/* bcr  [31:0]  OCR        R1 (R4)  */"
.br
.ti -1c
.RI "#define \fBSD_APP_SEND_SCR\fP   51		/* adtc                    R1   */"
.br
.ti -1c
.RI "#define \fBR1_OUT_OF_RANGE\fP   (1UL << 31)	/* er, c */"
.br
.RI "\fIMMC status in R1
.br
 Type
.br
 e : error bit
.br
 s : status bit
.br
 r : detected and set for the actual command response
.br
 x : detected and set during command execution\&. the host must poll the card by sending status command in order to read these bits\&. Clear condition
.br
 a : according to the card state
.br
 b : always related to the previous command\&. Reception of a valid command will clear it (with a delay of one command)
.br
 c : clear by read
.br
 \fP"
.ti -1c
.RI "#define \fBR1_ADDRESS_ERROR\fP   (1 << 30)	/* erx, c */"
.br
.ti -1c
.RI "#define \fBR1_BLOCK_LEN_ERROR\fP   (1 << 29)	/* er, c */"
.br
.ti -1c
.RI "#define \fBR1_ERASE_SEQ_ERROR\fP   (1 << 28)	/* er, c */"
.br
.ti -1c
.RI "#define \fBR1_ERASE_PARAM\fP   (1 << 27)	/* ex, c */"
.br
.ti -1c
.RI "#define \fBR1_WP_VIOLATION\fP   (1 << 26)	/* erx, c */"
.br
.ti -1c
.RI "#define \fBR1_CARD_IS_LOCKED\fP   (1 << 25)	/* sx, a */"
.br
.ti -1c
.RI "#define \fBR1_LOCK_UNLOCK_FAILED\fP   (1 << 24)	/* erx, c */"
.br
.ti -1c
.RI "#define \fBR1_COM_CRC_ERROR\fP   (1 << 23)	/* er, b */"
.br
.ti -1c
.RI "#define \fBR1_ILLEGAL_COMMAND\fP   (1 << 22)	/* er, b */"
.br
.ti -1c
.RI "#define \fBR1_CARD_ECC_FAILED\fP   (1 << 21)	/* ex, c */"
.br
.ti -1c
.RI "#define \fBR1_CC_ERROR\fP   (1 << 20)	/* erx, c */"
.br
.ti -1c
.RI "#define \fBR1_ERROR\fP   (1 << 19)	/* erx, c */"
.br
.ti -1c
.RI "#define \fBR1_UNDERRUN\fP   (1 << 18)	/* ex, c */"
.br
.ti -1c
.RI "#define \fBR1_OVERRUN\fP   (1 << 17)	/* ex, c */"
.br
.ti -1c
.RI "#define \fBR1_CID_CSD_OVERWRITE\fP   (1 << 16)	/* erx, c, CID/CSD overwrite */"
.br
.ti -1c
.RI "#define \fBR1_WP_ERASE_SKIP\fP   (1 << 15)	/* sx, c */"
.br
.ti -1c
.RI "#define \fBR1_CARD_ECC_DISABLED\fP   (1 << 14)	/* sx, a */"
.br
.ti -1c
.RI "#define \fBR1_ERASE_RESET\fP   (1 << 13)	/* sr, c */"
.br
.ti -1c
.RI "#define \fBR1_STATUS\fP(x)   (x & 0xFFFFE000)"
.br
.ti -1c
.RI "#define \fBR1_CURRENT_STATE\fP(x)   ((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */"
.br
.ti -1c
.RI "#define \fBR1_READY_FOR_DATA\fP   (1 << 8)	/* sx, a */"
.br
.ti -1c
.RI "#define \fBR1_APP_CMD\fP   (1 << 5)	/* sr, c */"
.br
.ti -1c
.RI "#define \fBOCR_ALL_READY\fP   (1UL << 31)	/* Card Power up status bit */"
.br
.RI "\fISD/MMC card OCR register bits\&. \fP"
.ti -1c
.RI "#define \fBOCR_HC_CCS\fP   (1 << 30)	/* High capacity card */"
.br
.ti -1c
.RI "#define \fBOCR_VOLTAGE_RANGE_MSK\fP   (0x00FF8000)"
.br
.ti -1c
.RI "#define \fBSD_SEND_IF_ARG\fP   0x000001AA"
.br
.ti -1c
.RI "#define \fBSD_SEND_IF_ECHO_MSK\fP   0x000000FF"
.br
.ti -1c
.RI "#define \fBSD_SEND_IF_RESP\fP   0x000000AA"
.br
.ti -1c
.RI "#define \fBCMDRESP_R3_OCR_VAL\fP(n)   (((uint32_t) n) & 0xFFFFFF)"
.br
.RI "\fIR3 response definitions\&. \fP"
.ti -1c
.RI "#define \fBCMDRESP_R3_S18A\fP   (((uint32_t) 1 ) << 24)"
.br
.ti -1c
.RI "#define \fBCMDRESP_R3_HC_CCS\fP   (((uint32_t) 1 ) << 30)"
.br
.ti -1c
.RI "#define \fBCMDRESP_R3_INIT_COMPLETE\fP   (((uint32_t) 1 ) << 31)"
.br
.ti -1c
.RI "#define \fBCMDRESP_R6_RCA_VAL\fP(n)   (((uint32_t) (n >> 16)) & 0xFFFF)"
.br
.RI "\fIR6 response definitions\&. \fP"
.ti -1c
.RI "#define \fBCMDRESP_R6_CARD_STATUS\fP(n)"
.br
.ti -1c
.RI "#define \fBCMDRESP_R7_CHECK_PATTERN\fP(n)   (((uint32_t) n ) & 0xFF)"
.br
.RI "\fIR7 response definitions\&. \fP"
.ti -1c
.RI "#define \fBCMDRESP_R7_VOLTAGE_ACCEPTED\fP   (((uint32_t) 1 ) << 8)"
.br
.ti -1c
.RI "#define \fBCMD3_RCA\fP(n)   (((uint32_t) (n & 0xFFFF) ) << 16)"
.br
.RI "\fICMD3 command definitions\&. \fP"
.ti -1c
.RI "#define \fBCMD7_RCA\fP(n)   (((uint32_t) (n & 0xFFFF) ) << 16)"
.br
.RI "\fICMD7 command definitions\&. \fP"
.ti -1c
.RI "#define \fBCMD8_CHECKPATTERN\fP(n)   (((uint32_t) (n & 0xFF) ) << 0)"
.br
.RI "\fICMD8 command definitions\&. \fP"
.ti -1c
.RI "#define \fBCMD8_DEF_PATTERN\fP   (0xAA)"
.br
.ti -1c
.RI "#define \fBCMD8_VOLTAGESUPPLIED_27_36\fP   (((uint32_t) 1 ) << 8)"
.br
.ti -1c
.RI "#define \fBCMD9_RCA\fP(n)   (((uint32_t) (n & 0xFFFF) ) << 16)"
.br
.RI "\fICMD9 command definitions\&. \fP"
.ti -1c
.RI "#define \fBCMD13_RCA\fP(n)   (((uint32_t) (n & 0xFFFF) ) << 16)"
.br
.RI "\fICMD13 command definitions\&. \fP"
.ti -1c
.RI "#define \fBCMD55_RCA\fP(n)   (((uint32_t) (n & 0xFFFF) ) << 16)"
.br
.RI "\fIAPP_CMD command definitions\&. \fP"
.ti -1c
.RI "#define \fBACMD41_OCR\fP(n)   (((uint32_t) n) & 0xFFFFFF)"
.br
.RI "\fIACMD41 command definitions\&. \fP"
.ti -1c
.RI "#define \fBACMD41_S18R\fP   (((uint32_t) 1 ) << 24)"
.br
.ti -1c
.RI "#define \fBACMD41_XPC\fP   (((uint32_t) 1 ) << 28)"
.br
.ti -1c
.RI "#define \fBACMD41_HCS\fP   (((uint32_t) 1 ) << 30)"
.br
.ti -1c
.RI "#define \fBACMD6_BUS_WIDTH\fP(n)   ((uint32_t) n & 0x03)"
.br
.RI "\fIACMD6 command definitions\&. \fP"
.ti -1c
.RI "#define \fBACMD6_BUS_WIDTH_1\fP   (0)"
.br
.ti -1c
.RI "#define \fBACMD6_BUS_WIDTH_4\fP   (2)"
.br
.ti -1c
.RI "#define \fBCARD_TYPE_SD\fP   (1 << 0)"
.br
.RI "\fICard type defines\&. \fP"
.ti -1c
.RI "#define \fBCARD_TYPE_4BIT\fP   (1 << 1)"
.br
.ti -1c
.RI "#define \fBCARD_TYPE_8BIT\fP   (1 << 2)"
.br
.ti -1c
.RI "#define \fBCARD_TYPE_HC\fP   (\fBOCR_HC_CCS\fP)"
.br
.ti -1c
.RI "#define \fBMMC_SECTOR_SIZE\fP   512"
.br
.RI "\fISD/MMC sector size in bytes\&. \fP"
.ti -1c
.RI "#define \fBSD_MMC_ENUM_CLOCK\fP   400000"
.br
.RI "\fITypical enumeration clock rate\&. \fP"
.ti -1c
.RI "#define \fBMMC_MAX_CLOCK\fP   20000000"
.br
.RI "\fIMax MMC clock rate\&. \fP"
.ti -1c
.RI "#define \fBMMC_LOW_BUS_MAX_CLOCK\fP   26000000"
.br
.RI "\fIType 0 MMC card max clock rate\&. \fP"
.ti -1c
.RI "#define \fBMMC_HIGH_BUS_MAX_CLOCK\fP   52000000"
.br
.RI "\fIType 1 MMC card max clock rate\&. \fP"
.ti -1c
.RI "#define \fBSD_MAX_CLOCK\fP   25000000"
.br
.RI "\fIMax SD clock rate\&. \fP"
.in -1c
.SS "'typedefs'"

.in +1c
.ti -1c
.RI "typedef void(* \fBSDMMC_EVSETUP_FUNC_T\fP) (void *)"
.br
.ti -1c
.RI "typedef uint32_t(* \fBSDMMC_EVWAIT_FUNC_T\fP) (void)"
.br
.ti -1c
.RI "typedef void(* \fBSDMMC_MSDELAY_FUNC_T\fP) (uint32_t)"
.br
.in -1c
.SS "Enumeraciones"

.in +1c
.ti -1c
.RI "enum \fBSD_APP_CMD_T\fP { \fBSD_SET_BUS_WIDTH\fP, \fBSD_SEND_STATUS\fP, \fBSD_SEND_WR_BLOCKS\fP, \fBSD_SET_ERASE_COUNT\fP, \fBSD_SENDOP_COND\fP, \fBSD_CLEAR_CARD_DET\fP, \fBSD_SEND_SCR\fP, \fBSD_INVALID_APP_CMD\fP }
.RI "\fISD/MMC application specific commands for SD cards only - these must be preceded by the SDMMC CMD55 to work correctly\&. \fP""
.br
.ti -1c
.RI "enum \fBSDMMC_RESPONSE_T\fP { \fBSDMMC_RESPONSE_R1\fP, \fBSDMMC_RESPONSE_R1B\fP, \fBSDMMC_RESPONSE_R2\fP, \fBSDMMC_RESPONSE_R3\fP, \fBSDMMC_RESPONSE_R4\fP, \fBSDMMC_RESPONSE_R5\fP, \fBSDMMC_RESPONSE_R6\fP, \fBSDMMC_RESPONSE_NONE\fP }
.RI "\fIPossible SDMMC response types\&. \fP""
.br
.ti -1c
.RI "enum \fBSDMMC_STATE_T\fP { \fBSDMMC_IDLE_ST\fP = 0, \fBSDMMC_READY_ST\fP, \fBSDMMC_IDENT_ST\fP, \fBSDMMC_STBY_ST\fP, \fBSDMMC_TRAN_ST\fP, \fBSDMMC_DATA_ST\fP, \fBSDMMC_RCV_ST\fP, \fBSDMMC_PRG_ST\fP, \fBSDMMC_DIS_ST\fP }
.RI "\fIPossible SDMMC card state types\&. \fP""
.br
.in -1c
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para Ejercicio 1 - TP 5 del código fuente\&.
